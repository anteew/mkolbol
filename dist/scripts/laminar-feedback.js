#!/usr/bin/env -S node --enable-source-maps
import fs from 'node:fs';
import path from 'node:path';
function readJsonl(file) {
    if (!fs.existsSync(file))
        return [];
    const lines = fs.readFileSync(file, 'utf8').split(/\r?\n/).filter(Boolean);
    const rows = [];
    for (const line of lines) {
        try {
            rows.push(JSON.parse(line));
        }
        catch { }
    }
    return rows;
}
function ensureDir(dir) {
    fs.mkdirSync(dir, { recursive: true });
}
function nowStamp() {
    return new Date().toISOString().replace(/[:.]/g, '');
}
function main() {
    const reportsDir = path.resolve('reports');
    const summaryPath = path.join(reportsDir, 'summary.jsonl');
    const indexPath = path.join(reportsDir, 'index.json');
    const feedbackDir = path.resolve('project-manager/laminar-feedback');
    ensureDir(feedbackDir);
    const rows = readJsonl(summaryPath);
    const byStatus = new Map();
    const byFile = new Map();
    let total = 0;
    for (const r of rows) {
        const s = (r.status || 'unknown').toLowerCase();
        byStatus.set(s, (byStatus.get(s) || 0) + 1);
        total++;
        const loc = r.location || '';
        const file = (loc.replace(/:\d+$/, '') || 'unknown');
        if (!byFile.has(file))
            byFile.set(file, { pass: 0, fail: 0, total: 0 });
        const bucket = byFile.get(file);
        bucket.total++;
        if (s === 'pass')
            bucket.pass++;
        else if (s === 'fail')
            bucket.fail++;
    }
    const topByFail = Array.from(byFile.entries())
        .sort((a, b) => (b[1].fail - a[1].fail) || (b[1].total - a[1].total))
        .slice(0, 10);
    let indexNote = '';
    if (fs.existsSync(indexPath)) {
        try {
            const idx = JSON.parse(fs.readFileSync(indexPath, 'utf8'));
            const caseCount = Array.isArray(idx?.artifacts)
                ? idx.artifacts.length
                : Array.isArray(idx?.cases)
                    ? idx.cases.length
                    : 0;
            indexNote = `Index contains ${caseCount} cases.`;
        }
        catch { }
    }
    const stamp = nowStamp();
    const outMd = path.join(feedbackDir, `feedback-${stamp}.md`);
    const pass = byStatus.get('pass') || 0;
    const fail = byStatus.get('fail') || 0;
    const unknown = byStatus.get('unknown') || 0;
    const md = [
        `# Laminar Dogfooding Feedback (${new Date().toISOString()})`,
        '',
        `Total tests observed: ${total} (pass: ${pass}, fail: ${fail}, other: ${unknown})`,
        indexNote ? `- ${indexNote}` : '',
        '',
        '## Top files by failures',
        ...(topByFail.length
            ? topByFail.map(([file, s]) => `- ${file} â€” fail: ${s.fail}, pass: ${s.pass}, total: ${s.total}`)
            : ['- No failures recorded in this run']),
        '',
        '## Feature request seeds (to triage)',
        '- [ ] Summarize repeated hints/failures across last N runs',
        '- [ ] Surface longest-duration tests and suggest sharding/parallelism',
        '- [ ] Auto-attach most relevant artifacts per fail (budget-aware)',
        '',
        '> Generated by scripts/laminar-feedback.ts'
    ].filter(Boolean).join('\n');
    fs.writeFileSync(outMd, md, 'utf8');
    // Mirror to a stable pointer for convenience
    fs.writeFileSync(path.join(feedbackDir, 'latest.md'), md, 'utf8');
    // Also emit a minimal JSONL bundle for machine consumption
    const outJsonl = path.join(feedbackDir, `feedback-${stamp}.jsonl`);
    const blob = {
        when: new Date().toISOString(),
        totals: { total, pass, fail, unknown },
        topByFail: topByFail.map(([file, s]) => ({ file, ...s }))
    };
    fs.writeFileSync(outJsonl, JSON.stringify(blob) + '\n', 'utf8');
}
main();
//# sourceMappingURL=laminar-feedback.js.map