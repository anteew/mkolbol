diff --git a/src/wrappers/ExternalServerWrapper.ts b/src/wrappers/ExternalServerWrapper.ts
index b36e2f5..995b958 100644
--- a/src/wrappers/ExternalServerWrapper.ts
+++ b/src/wrappers/ExternalServerWrapper.ts
@@ -4,6 +4,7 @@ import { Hostess } from '../hostess/Hostess.js';
 import type { Pipe } from '../types/stream.js';
 import type { ExternalServerManifest, ProcessInfo } from '../types.js';
 import crypto from 'node:crypto';
+import { debug } from '../debug/api.js';
 
 export class ExternalServerWrapper {
   protected process?: ChildProcess;
@@ -54,6 +55,8 @@ export class ExternalServerWrapper {
       throw new Error(`Process already running for ${this.manifest.servername}`);
     }
 
+    debug.emit('external', 'server.starting', { servername: this.manifest.servername }, 'info');
+
     const env = { ...process.env, ...this.manifest.env };
     
     this.process = spawn(this.manifest.command, this.manifest.args, {
@@ -64,12 +67,37 @@ export class ExternalServerWrapper {
 
     this.spawnTime = Date.now();
 
+    debug.emit('external', 'server.started', { 
+      servername: this.manifest.servername, 
+      pid: this.process.pid 
+    }, 'info');
+
     if (!this.process.stdin || !this.process.stdout || !this.process.stderr) {
       throw new Error('Failed to get process stdio streams');
     }
 
+    this._inputPipe.on('data', (chunk) => {
+      debug.emit('external', 'server.input', { 
+        servername: this.manifest.servername, 
+        bytes: chunk.length 
+      }, 'trace');
+    });
     this._inputPipe.pipe(this.process.stdin);
+    
+    this.process.stdout.on('data', (chunk) => {
+      debug.emit('external', 'server.output', { 
+        servername: this.manifest.servername, 
+        bytes: chunk.length 
+      }, 'trace');
+    });
     this.process.stdout.pipe(this._outputPipe);
+    
+    this.process.stderr.on('data', (chunk) => {
+      debug.emit('external', 'server.error', { 
+        servername: this.manifest.servername, 
+        bytes: chunk.length 
+      }, 'trace');
+    });
     this.process.stderr.pipe(this._errorPipe);
 
     this.process.on('exit', (code, signal) => {
@@ -97,6 +125,8 @@ export class ExternalServerWrapper {
   async shutdown(timeout: number = 5000): Promise<void> {
     if (!this.process) return;
 
+    debug.emit('external', 'server.stopping', { servername: this.manifest.servername }, 'info');
+
     this.explicitShutdown = true;
 
     return new Promise((resolve) => {
@@ -114,6 +144,7 @@ export class ExternalServerWrapper {
       this.process.once('exit', () => {
         clearTimeout(killTimer);
         this.process = undefined;
+        debug.emit('external', 'server.stopped', { servername: this.manifest.servername }, 'info');
         resolve();
       });
 
diff --git a/src/wrappers/PTYServerWrapper.ts b/src/wrappers/PTYServerWrapper.ts
index 5e6674e..1941cde 100644
--- a/src/wrappers/PTYServerWrapper.ts
+++ b/src/wrappers/PTYServerWrapper.ts
@@ -3,6 +3,7 @@ import { ExternalServerWrapper } from './ExternalServerWrapper.js';
 import { Kernel } from '../kernel/Kernel.js';
 import { Hostess } from '../hostess/Hostess.js';
 import type { ExternalServerManifest } from '../types.js';
+import { debug } from '../debug/api.js';
 
 export class PTYServerWrapper extends ExternalServerWrapper {
   private ptyProcess?: pty.IPty;
@@ -27,6 +28,8 @@ export class PTYServerWrapper extends ExternalServerWrapper {
       throw new Error(`PTY process already running for ${this.manifest.servername}`);
     }
 
+    debug.emit('pty', 'server.starting', { servername: this.manifest.servername }, 'info');
+
     const env = { ...process.env, ...this.manifest.env };
     const shell = this.manifest.shell || this.manifest.command;
     const args = this.manifest.shellArgs || this.manifest.args;
@@ -42,7 +45,16 @@ export class PTYServerWrapper extends ExternalServerWrapper {
 
     this.spawnTime = Date.now();
 
+    debug.emit('pty', 'server.started', { 
+      servername: this.manifest.servername, 
+      pid: this.ptyProcess.pid 
+    }, 'info');
+
     this.dataDisposable = this.ptyProcess.onData((data) => {
+      debug.emit('pty', 'server.output', { 
+        servername: this.manifest.servername, 
+        bytes: data.length 
+      }, 'trace');
       this._outputPipe.write(data);
     });
 
@@ -56,6 +68,10 @@ export class PTYServerWrapper extends ExternalServerWrapper {
 
     this._inputPipe.on('data', (data) => {
       if (this.ptyProcess) {
+        debug.emit('pty', 'server.input', { 
+          servername: this.manifest.servername, 
+          bytes: data.length 
+        }, 'trace');
         this.ptyProcess.write(data.toString());
       }
     });
@@ -75,6 +91,8 @@ export class PTYServerWrapper extends ExternalServerWrapper {
   async shutdown(timeout: number = 100): Promise<void> {
     if (!this.ptyProcess) return;
 
+    debug.emit('pty', 'server.stopping', { servername: this.manifest.servername }, 'info');
+
     this.explicitShutdown = true;
     
     if (this.dataDisposable) {
@@ -90,6 +108,8 @@ export class PTYServerWrapper extends ExternalServerWrapper {
     } catch (err) {
     }
     
+    debug.emit('pty', 'server.stopped', { servername: this.manifest.servername }, 'info');
+    
     await new Promise(resolve => setTimeout(resolve, timeout));
   }
 
