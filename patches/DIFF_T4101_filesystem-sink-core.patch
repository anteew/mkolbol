diff --git a/examples/configs/http-logs-local.yml b/examples/configs/http-logs-local.yml
new file mode 100644
index 0000000..dd664eb
--- /dev/null
+++ b/examples/configs/http-logs-local.yml
@@ -0,0 +1,21 @@
+nodes:
+  - id: http-source
+    module: ExternalProcess
+    params:
+      command: curl
+      args:
+        - -s
+        - -i
+        - https://httpbin.org/get
+      ioMode: stdio
+      restart: never
+      
+  - id: log-sink
+    module: FilesystemSink
+    params:
+      path: ./logs/http-response.log
+      mode: append
+
+connections:
+  - from: http-source.output
+    to: log-sink.input
diff --git a/src/executor/Executor.ts b/src/executor/Executor.ts
index 4a792a5..2161816 100644
--- a/src/executor/Executor.ts
+++ b/src/executor/Executor.ts
@@ -723,6 +723,7 @@ export class Executor {
       'TimerSource': '../modules/timer.js',
       'UppercaseTransform': '../modules/uppercase.js',
       'ConsoleSink': '../modules/consoleSink.js',
+      'FilesystemSink': '../modules/filesystem-sink.js',
     };
     const relativePath = moduleMap[moduleName];
     if (!relativePath) {
diff --git a/src/executor/moduleRegistry.ts b/src/executor/moduleRegistry.ts
index dd58055..204870b 100644
--- a/src/executor/moduleRegistry.ts
+++ b/src/executor/moduleRegistry.ts
@@ -2,6 +2,7 @@ import { Kernel } from '../kernel/Kernel.js';
 import { TimerSource } from '../modules/timer.js';
 import { UppercaseTransform } from '../modules/uppercase.js';
 import { ConsoleSink } from '../modules/consoleSink.js';
+import { FilesystemSink } from '../modules/filesystem-sink.js';
 
 export type ModuleConstructor = new (kernel: Kernel, ...args: any[]) => any;
 
@@ -12,6 +13,7 @@ export class ModuleRegistry {
     this.register('TimerSource', TimerSource);
     this.register('UppercaseTransform', UppercaseTransform);
     this.register('ConsoleSink', ConsoleSink);
+    this.register('FilesystemSink', FilesystemSink);
   }
 
   register(name: string, constructor: any): void {
diff --git a/src/modules/filesystem-sink.ts b/src/modules/filesystem-sink.ts
new file mode 100644
index 0000000..db1354a
--- /dev/null
+++ b/src/modules/filesystem-sink.ts
@@ -0,0 +1,133 @@
+import { Writable } from 'stream';
+import { createWriteStream, WriteStream } from 'fs';
+import { mkdir } from 'fs/promises';
+import { dirname } from 'path';
+import { Kernel } from '../kernel/Kernel.js';
+import type { Pipe } from '../types/stream.js';
+import { debug } from '../debug/api.js';
+
+export interface FilesystemSinkOptions {
+  path: string;
+  mode?: 'append' | 'truncate';
+  encoding?: BufferEncoding;
+  highWaterMark?: number;
+}
+
+export class FilesystemSink {
+  private _inputPipe: Pipe;
+  private fileStream?: WriteStream;
+  private options: Required<FilesystemSinkOptions>;
+  private writeCount = 0;
+  private byteCount = 0;
+
+  constructor(
+    protected kernel: Kernel,
+    options: FilesystemSinkOptions
+  ) {
+    this.options = {
+      path: options.path,
+      mode: options.mode ?? 'append',
+      encoding: options.encoding ?? 'utf8',
+      highWaterMark: options.highWaterMark ?? 16384
+    };
+
+    this._inputPipe = kernel.createPipe();
+  }
+
+  get inputPipe(): Pipe {
+    return this._inputPipe;
+  }
+
+  async start(): Promise<void> {
+    debug.emit('filesystem-sink', 'start', { path: this.options.path, mode: this.options.mode }, 'info');
+
+    // Ensure directory exists
+    const dir = dirname(this.options.path);
+    await mkdir(dir, { recursive: true });
+
+    // Create write stream
+    const flags = this.options.mode === 'append' ? 'a' : 'w';
+    this.fileStream = createWriteStream(this.options.path, {
+      flags,
+      encoding: this.options.encoding,
+      highWaterMark: this.options.highWaterMark
+    });
+
+    // Pipe input to file - just pipe directly, don't manually handle data
+    this._inputPipe.pipe(this.fileStream);
+
+    // Track writes for statistics
+    this._inputPipe.on('data', (chunk) => {
+      this.writeCount++;
+      this.byteCount += chunk.length;
+      
+      debug.emit('filesystem-sink', 'write', {
+        path: this.options.path,
+        bytes: chunk.length,
+        totalWrites: this.writeCount,
+        totalBytes: this.byteCount
+      }, 'trace');
+    });
+
+    this._inputPipe.on('end', () => {
+      debug.emit('filesystem-sink', 'input-end', {
+        path: this.options.path,
+        totalWrites: this.writeCount,
+        totalBytes: this.byteCount
+      }, 'info');
+    });
+
+    this.fileStream.on('error', (err) => {
+      debug.emit('filesystem-sink', 'error', {
+        path: this.options.path,
+        error: err.message
+      }, 'error');
+
+      console.error(`[FilesystemSink] Error writing to ${this.options.path}:`, err);
+    });
+
+    this.fileStream.on('finish', () => {
+      debug.emit('filesystem-sink', 'finish', {
+        path: this.options.path,
+        totalWrites: this.writeCount,
+        totalBytes: this.byteCount
+      }, 'info');
+    });
+  }
+
+  async stop(): Promise<void> {
+    debug.emit('filesystem-sink', 'stop', {
+      path: this.options.path,
+      totalWrites: this.writeCount,
+      totalBytes: this.byteCount
+    }, 'info');
+
+    if (!this.fileStream) {
+      return;
+    }
+
+    return new Promise((resolve, reject) => {
+      this.fileStream!.once('finish', () => {
+        debug.emit('filesystem-sink', 'stopped', {
+          path: this.options.path
+        }, 'info');
+        this.fileStream = undefined;
+        resolve();
+      });
+
+      this.fileStream!.once('error', (err) => {
+        reject(err);
+      });
+
+      // End the input pipe which will end the file stream
+      this._inputPipe.end();
+    });
+  }
+
+  getStats(): { writeCount: number; byteCount: number } {
+    return {
+      writeCount: this.writeCount,
+      byteCount: this.byteCount
+    };
+  }
+}
diff --git a/tests/renderers/filesystemSink.spec.ts b/tests/renderers/filesystemSink.spec.ts
new file mode 100644
index 0000000..f8b4675
--- /dev/null
+++ b/tests/renderers/filesystemSink.spec.ts
@@ -0,0 +1,145 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import { Kernel } from '../../src/kernel/Kernel.js';
+import { FilesystemSink } from '../../src/modules/filesystem-sink.js';
+import { readFile, rm, mkdir } from 'fs/promises';
+import { existsSync } from 'fs';
+import { join } from 'path';
+import { tmpdir } from 'os';
+
+describe('FilesystemSink', () => {
+  let kernel: Kernel;
+  let testDir: string;
+
+  beforeEach(async () => {
+    kernel = new Kernel();
+    testDir = join(tmpdir(), `filesystem-sink-test-${Date.now()}`);
+    await mkdir(testDir, { recursive: true });
+  });
+
+  afterEach(async () => {
+    if (existsSync(testDir)) {
+      await rm(testDir, { recursive: true, force: true });
+    }
+  });
+
+  it('should create file and write data', async () => {
+    const filePath = join(testDir, 'test.log');
+    const sink = new FilesystemSink(kernel, { path: filePath });
+
+    await sink.start();
+    sink.inputPipe.write('line 1\n');
+    sink.inputPipe.write('line 2\n');
+    await sink.stop();
+
+    const content = await readFile(filePath, 'utf8');
+    expect(content).toBe('line 1\nline 2\n');
+  });
+
+  it('should append to existing file in append mode', async () => {
+    const filePath = join(testDir, 'append.log');
+    
+    const sink1 = new FilesystemSink(kernel, { path: filePath, mode: 'append' });
+    await sink1.start();
+    sink1.inputPipe.write('first\n');
+    await sink1.stop();
+
+    const sink2 = new FilesystemSink(kernel, { path: filePath, mode: 'append' });
+    await sink2.start();
+    sink2.inputPipe.write('second\n');
+    await sink2.stop();
+
+    const content = await readFile(filePath, 'utf8');
+    expect(content).toBe('first\nsecond\n');
+  });
+
+  it('should truncate existing file in truncate mode', async () => {
+    const filePath = join(testDir, 'truncate.log');
+    
+    const sink1 = new FilesystemSink(kernel, { path: filePath, mode: 'truncate' });
+    await sink1.start();
+    sink1.inputPipe.write('first\n');
+    await sink1.stop();
+
+    const sink2 = new FilesystemSink(kernel, { path: filePath, mode: 'truncate' });
+    await sink2.start();
+    sink2.inputPipe.write('second\n');
+    await sink2.stop();
+
+    const content = await readFile(filePath, 'utf8');
+    expect(content).toBe('second\n');
+  });
+
+  it('should create nested directories automatically', async () => {
+    const filePath = join(testDir, 'nested', 'deep', 'file.log');
+    const sink = new FilesystemSink(kernel, { path: filePath });
+
+    await sink.start();
+    sink.inputPipe.write('nested content\n');
+    await sink.stop();
+
+    const content = await readFile(filePath, 'utf8');
+    expect(content).toBe('nested content\n');
+  });
+
+  it('should track write statistics', async () => {
+    const filePath = join(testDir, 'stats.log');
+    const sink = new FilesystemSink(kernel, { path: filePath });
+
+    await sink.start();
+    sink.inputPipe.write('data1\n');
+    sink.inputPipe.write('data2\n');
+    sink.inputPipe.write('data3\n');
+    
+    const statsBefore = sink.getStats();
+    expect(statsBefore.writeCount).toBe(3);
+    
+    await sink.stop();
+
+    const stats = sink.getStats();
+    expect(stats.writeCount).toBe(3);
+    expect(stats.byteCount).toBeGreaterThan(0);
+  });
+
+  it('should handle binary data', async () => {
+    const filePath = join(testDir, 'binary.dat');
+    const sink = new FilesystemSink(kernel, { path: filePath });
+
+    await sink.start();
+    const binaryData = Buffer.from([0x01, 0x02, 0x03, 0x04, 0x05]);
+    sink.inputPipe.write(binaryData);
+    await sink.stop();
+
+    const content = await readFile(filePath);
+    expect(content).toEqual(binaryData);
+  });
+
+  it('should handle large writes', async () => {
+    const filePath = join(testDir, 'large.log');
+    const sink = new FilesystemSink(kernel, { path: filePath });
+
+    await sink.start();
+    const largeData = Buffer.alloc(64 * 1024, 'x');
+    sink.inputPipe.write(largeData);
+    await sink.stop();
+
+    const content = await readFile(filePath);
+    expect(content.length).toBe(largeData.length);
+  });
+
+  it('should handle multiple sequential writes', async () => {
+    const filePath = join(testDir, 'sequential.log');
+    const sink = new FilesystemSink(kernel, { path: filePath });
+
+    await sink.start();
+    for (let i = 0; i < 50; i++) {
+      sink.inputPipe.write(`line ${i}\n`);
+    }
+    await sink.stop();
+
+    const content = await readFile(filePath, 'utf8');
+    const lines = content.trim().split('\n');
+    expect(lines.length).toBe(50);
+    expect(lines[0]).toBe('line 0');
+    expect(lines[49]).toBe('line 49');
+  });
+});
