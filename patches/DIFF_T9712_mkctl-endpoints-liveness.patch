diff --git a/docs/devex/mkctl-cookbook.md b/docs/devex/mkctl-cookbook.md
index 3111deb..335eddc 100644
--- a/docs/devex/mkctl-cookbook.md
+++ b/docs/devex/mkctl-cookbook.md
@@ -359,6 +359,420 @@ mkctl endpoints --json --filter type=external | jq '.[].id'
 
 ---
 
+## Monitoring Endpoint Liveness
+
+### Built-in Watch Mode with TTL Status
+
+mkctl has a built-in watch mode that displays real-time liveness status:
+
+```bash
+# Terminal 1: Start topology
+mkctl run --file examples/configs/external-pty.yaml --duration 60
+
+# Terminal 2: Watch with liveness indicators
+mkctl endpoints --watch --interval 2
+```
+
+**Output:**
+```
+[2025-10-17T04:15:23.456Z] Watching endpoints (refresh every 2s)...
+Press Ctrl+C to stop.
+
+Registered Endpoints (RoutingServer snapshot)
+
+ID:          localhost:web:0x0001:...
+Type:        external
+Coordinates: node:web
+Status:      ✓ healthy
+TTL:         28s
+Updated:     2025-10-17T04:15:21.456Z
+
+ID:          localhost:sink:0x0002:...
+Type:        inproc
+Coordinates: node:sink
+Status:      ⚠ stale
+TTL:         5s
+Updated:     2025-10-17T04:14:58.456Z
+```
+
+**Status Indicators:**
+- `✓ healthy` — Endpoint is fresh (age < 70% of TTL)
+- `⚠ stale` — Endpoint is aging (age ≥ 70% of TTL but < 100%)
+- `✗ expired` — Endpoint has exceeded TTL (age ≥ TTL)
+
+**TTL Countdown:**
+- Shows seconds remaining until expiration
+- Calculated as: `expiresAt - now` (or `ttlMs - age`)
+- Default TTL is 30 seconds if not specified
+
+### JSON Output with Status
+
+Get structured liveness data for automation:
+
+```bash
+mkctl endpoints --json | jq '.[] | {id, status, ttl: .ttlRemaining}'
+```
+
+**Output:**
+```json
+{
+  "id": "localhost:web:0x0001:...",
+  "status": "healthy",
+  "ttl": 28000
+}
+{
+  "id": "localhost:sink:0x0002:...",
+  "status": "stale",
+  "ttl": 5000
+}
+```
+
+### Custom Runtime Directory
+
+Specify a custom path for router snapshots:
+
+```bash
+mkctl endpoints --watch --runtime-dir /path/to/runtime --interval 1
+```
+
+This reads from `/path/to/runtime/reports/router-endpoints.json` instead of the default `./reports/router-endpoints.json`.
+
+### Watch Endpoints (External Polling)
+
+Alternatively, use the Unix `watch` command for simpler polling:
+
+```bash
+# Terminal 1: Start topology
+mkctl run --file examples/configs/external-pty.yaml --duration 60
+
+# Terminal 2: Watch endpoints every 2 seconds
+watch -n 2 'mkctl endpoints'
+```
+
+**Output:**
+```
+Every 2.0s: mkctl endpoints
+
+Registered Endpoints (2)
+
+ID:          localhost:web:0x0001:...
+Type:        external
+Coordinates: node:web
+Updated:     2025-10-17T04:15:23.456Z
+
+ID:          localhost:sink:0x0002:...
+Type:        inproc
+Coordinates: node:sink
+Updated:     2025-10-17T04:15:23.456Z
+```
+
+### Custom Watch Script (Liveness Monitor)
+
+Create a shell script to monitor endpoint health:
+
+```bash
+#!/bin/bash
+# watch-endpoints.sh — Monitor endpoint liveness
+
+INTERVAL=1  # seconds
+COUNT=0
+
+echo "Monitoring endpoint liveness (Ctrl+C to stop)"
+echo "================================================"
+
+while true; do
+  COUNT=$((COUNT + 1))
+  TIMESTAMP=$(date '+%H:%M:%S')
+
+  # Get endpoint count
+  if [ -f reports/router-endpoints.json ]; then
+    TOTAL=$(jq 'length' reports/router-endpoints.json)
+    echo "[$TIMESTAMP] Sweep #$COUNT: $TOTAL endpoints registered"
+
+    # Show endpoint types
+    jq -r '.[] | "\(.type): \(.id | split(":")[1])"' reports/router-endpoints.json | \
+      sort | uniq -c | sed 's/^/  /'
+  else
+    echo "[$TIMESTAMP] Sweep #$COUNT: No router snapshot yet"
+  fi
+
+  echo ""
+  sleep $INTERVAL
+done
+```
+
+**Usage:**
+```bash
+# Make executable
+chmod +x watch-endpoints.sh
+
+# Terminal 1: Start topology
+mkctl run --file examples/configs/http-logs-local.yml --duration 60
+
+# Terminal 2: Monitor liveness
+./watch-endpoints.sh
+```
+
+**Output:**
+```
+Monitoring endpoint liveness (Ctrl+C to stop)
+================================================
+[12:34:56] Sweep #1: 2 endpoints registered
+  1 external: web
+  1 inproc: sink
+
+[12:34:57] Sweep #2: 2 endpoints registered
+  1 external: web
+  1 inproc: sink
+
+[12:34:58] Sweep #3: 2 endpoints registered
+  1 external: web
+  1 inproc: sink
+```
+
+### JSON Liveness Monitor
+
+Monitor endpoint liveness with JSON output for automation:
+
+```bash
+#!/bin/bash
+# json-liveness.sh — JSON endpoint liveness monitor
+
+INTERVAL=2
+
+while true; do
+  if [ -f reports/router-endpoints.json ]; then
+    TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
+    TOTAL=$(jq 'length' reports/router-endpoints.json)
+
+    # Extract endpoint summary
+    SUMMARY=$(jq -r '.[] | "\(.type)"' reports/router-endpoints.json | \
+              sort | uniq -c | jq -R -s 'split("\n") | map(select(length > 0))')
+
+    # Output JSON
+    jq -n \
+      --arg ts "$TIMESTAMP" \
+      --argjson total "$TOTAL" \
+      --argjson summary "$SUMMARY" \
+      '{timestamp: $ts, total_endpoints: $total, type_counts: $summary}'
+  else
+    echo '{"timestamp":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'","error":"No router snapshot"}'
+  fi
+
+  sleep $INTERVAL
+done
+```
+
+**Usage:**
+```bash
+chmod +x json-liveness.sh
+
+# Terminal 1: Start topology
+mkctl run --file examples/configs/http-logs-local.yml --duration 60
+
+# Terminal 2: Monitor as JSON
+./json-liveness.sh | jq '.'
+```
+
+**Output:**
+```json
+{
+  "timestamp": "2025-10-17T04:15:23Z",
+  "total_endpoints": 2,
+  "type_counts": [
+    "1 external",
+    "1 inproc"
+  ]
+}
+{
+  "timestamp": "2025-10-17T04:15:25Z",
+  "total_endpoints": 2,
+  "type_counts": [
+    "1 external",
+    "1 inproc"
+  ]
+}
+```
+
+### Watch with Timestamps
+
+Monitor endpoint registration/unregistration events:
+
+```bash
+# watch-changes.sh — Alert on endpoint changes
+
+PREV_COUNT=0
+
+while true; do
+  if [ -f reports/router-endpoints.json ]; then
+    CURR_COUNT=$(jq 'length' reports/router-endpoints.json)
+
+    if [ $CURR_COUNT -ne $PREV_COUNT ]; then
+      TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
+      DELTA=$((CURR_COUNT - PREV_COUNT))
+
+      if [ $DELTA -gt 0 ]; then
+        echo "[$TIMESTAMP] ✅ +$DELTA endpoint(s) registered (total: $CURR_COUNT)"
+      else
+        echo "[$TIMESTAMP] ❌ $((DELTA * -1)) endpoint(s) removed (total: $CURR_COUNT)"
+      fi
+
+      # Show current endpoints
+      jq -r '.[] | "  \(.type): \(.id | split(":")[1])"' reports/router-endpoints.json
+
+      PREV_COUNT=$CURR_COUNT
+    fi
+  fi
+
+  sleep 1
+done
+```
+
+**Usage:**
+```bash
+chmod +x watch-changes.sh
+
+# Terminal 1: Start topology
+mkctl run --file examples/configs/http-logs-local.yml --duration 60
+
+# Terminal 2: Watch for changes
+./watch-changes.sh
+```
+
+**Output:**
+```
+[2025-10-17 12:34:56] ✅ +2 endpoint(s) registered (total: 2)
+  external: web
+  inproc: sink
+
+# (later, if topology stops)
+[2025-10-17 12:35:56] ❌ 2 endpoint(s) removed (total: 0)
+```
+
+### Continuous Liveness Check (CI/CD)
+
+Use in CI pipelines to ensure endpoints remain live:
+
+```bash
+#!/bin/bash
+# ci-liveness-check.sh — Fail if endpoints drop during test
+
+DURATION=30  # seconds to monitor
+INTERVAL=2
+MIN_ENDPOINTS=2  # expected minimum
+
+echo "Monitoring endpoint liveness for ${DURATION}s..."
+
+START=$(date +%s)
+while [ $(($(date +%s) - START)) -lt $DURATION ]; do
+  if [ -f reports/router-endpoints.json ]; then
+    COUNT=$(jq 'length' reports/router-endpoints.json)
+
+    if [ $COUNT -lt $MIN_ENDPOINTS ]; then
+      echo "❌ FAIL: Only $COUNT endpoints (expected >= $MIN_ENDPOINTS)"
+      exit 1
+    fi
+
+    echo "[$(date +%H:%M:%S)] ✓ $COUNT endpoints alive"
+  else
+    echo "[$(date +%H:%M:%S)] ⚠ No router snapshot yet"
+  fi
+
+  sleep $INTERVAL
+done
+
+echo "✅ PASS: Endpoints remained live for ${DURATION}s"
+```
+
+**Usage in CI:**
+```yaml
+# .github/workflows/test.yml
+- name: Liveness check
+  run: |
+    mkctl run --file config.yml --duration 60 &
+    MKCTL_PID=$!
+
+    sleep 5  # Wait for startup
+    ./ci-liveness-check.sh
+
+    kill $MKCTL_PID
+```
+
+### Advanced: Stale Endpoint Detection
+
+Detect endpoints that haven't updated recently:
+
+```bash
+#!/bin/bash
+# stale-endpoints.sh — Find endpoints with old updatedAt timestamps
+
+STALE_THRESHOLD=10  # seconds
+
+while true; do
+  if [ -f reports/router-endpoints.json ]; then
+    NOW=$(date +%s)
+
+    jq -r --arg now "$NOW" --arg threshold "$STALE_THRESHOLD" '
+      .[] |
+      select((($now | tonumber) - (.updatedAt / 1000)) > ($threshold | tonumber)) |
+      "\(.id | split(":")[1]): stale for \((($now | tonumber) - (.updatedAt / 1000)) | floor)s"
+    ' reports/router-endpoints.json
+  fi
+
+  sleep 5
+done
+```
+
+**Output:**
+```
+web: stale for 12s
+# Alerts if endpoint hasn't updated in 10+ seconds
+```
+
+### Health Check Pattern
+
+Combine with health checks for complete liveness monitoring:
+
+```yaml
+# Complete liveness topology
+nodes:
+  - id: web
+    module: ExternalProcess
+    params:
+      command: node
+      args: ['server.js']
+      ioMode: stdio
+      healthCheck:
+        type: http
+        url: 'http://localhost:3000/health'
+        timeout: 5000
+        retries: 3
+    runMode: process
+
+  - id: sink
+    module: FilesystemSink
+    params:
+      path: reports/output.jsonl
+      format: jsonl
+```
+
+**Monitor both health and liveness:**
+```bash
+# Terminal 1: Run topology
+mkctl run --file liveness-topology.yml --duration 60
+
+# Terminal 2: Check health endpoint
+while true; do
+  curl -s http://localhost:3000/health || echo "❌ Health check failed"
+  sleep 2
+done
+
+# Terminal 3: Monitor endpoint registration
+watch -n 2 'mkctl endpoints | grep -c "Type:"'
+```
+
+---
+
 ## Common Topologies
 
 ### PTY Demo (Interactive Shell)
diff --git a/scripts/mkctl.ts b/scripts/mkctl.ts
index 4b761c0..43c2755 100644
--- a/scripts/mkctl.ts
+++ b/scripts/mkctl.ts
@@ -194,8 +194,17 @@ type EndpointSnapshot = {
   metadata?: Record<string, any>;
   announcedAt?: number;
   updatedAt?: number;
+  expiresAt?: number;
+  ttlMs?: number;
 };
 
+type LivenessStatus = 'healthy' | 'stale' | 'expired';
+
+interface EnhancedEndpoint extends EndpointSnapshot {
+  status: LivenessStatus;
+  ttlRemaining?: number;
+}
+
 async function loadEndpointSnapshot(): Promise<{ endpoints: EndpointSnapshot[]; source: 'router' | 'hostess' }> {
   const base = RUNTIME_DIR ? path.resolve(RUNTIME_DIR) : process.cwd();
   const routerSnapshotPath = path.resolve(base, 'reports', 'router-endpoints.json');
@@ -240,6 +249,8 @@ function normalizeRouterEndpoint(entry: any): EndpointSnapshot {
     metadata: entry && typeof entry.metadata === 'object' ? entry.metadata : undefined,
     announcedAt: typeof entry?.announcedAt === 'number' ? entry.announcedAt : undefined,
     updatedAt: typeof entry?.updatedAt === 'number' ? entry.updatedAt : undefined,
+    expiresAt: typeof entry?.expiresAt === 'number' ? entry.expiresAt : undefined,
+    ttlMs: typeof entry?.ttlMs === 'number' ? entry.ttlMs : undefined,
   };
 }
 
@@ -250,6 +261,47 @@ function formatTimestamp(value?: number): string {
   return date.toISOString();
 }
 
+function computeLiveness(endpoint: EndpointSnapshot, now: number): EnhancedEndpoint {
+  const DEFAULT_TTL = 30000;
+  const STALE_THRESHOLD = 0.7;
+
+  let status: LivenessStatus = 'healthy';
+  let ttlRemaining: number | undefined;
+
+  if (endpoint.updatedAt !== undefined) {
+    const ttl = endpoint.ttlMs ?? DEFAULT_TTL;
+    const age = now - endpoint.updatedAt;
+    ttlRemaining = Math.max(0, ttl - age);
+
+    if (age >= ttl) {
+      status = 'expired';
+    } else if (age >= ttl * STALE_THRESHOLD) {
+      status = 'stale';
+    }
+  }
+
+  return {
+    ...endpoint,
+    status,
+    ttlRemaining,
+  };
+}
+
+function formatTTL(ttlMs: number | undefined): string {
+  if (ttlMs === undefined) return 'n/a';
+  const seconds = Math.ceil(ttlMs / 1000);
+  if (seconds < 0) return '0s';
+  return `${seconds}s`;
+}
+
+function getStatusIcon(status: LivenessStatus): string {
+  switch (status) {
+    case 'healthy': return '✓';
+    case 'stale': return '⚠';
+    case 'expired': return '✗';
+  }
+}
+
 interface EndpointsArguments {
   watch: boolean;
   interval: number;
@@ -324,7 +376,7 @@ function applyFilters(endpoints: EndpointSnapshot[], filters: Array<{ key: strin
   });
 }
 
-function displayEndpoints(endpoints: EndpointSnapshot[], source: 'router' | 'hostess'): void {
+function displayEndpoints(endpoints: EndpointSnapshot[], source: 'router' | 'hostess', showLiveness = false): void {
   if (endpoints.length === 0) {
     console.log('No endpoints match the filters.');
     return;
@@ -333,10 +385,21 @@ function displayEndpoints(endpoints: EndpointSnapshot[], source: 'router' | 'hos
   console.log(`Registered Endpoints (${source === 'router' ? 'RoutingServer snapshot' : 'Hostess snapshot'})`);
   console.log('');
 
+  const now = Date.now();
   for (const endpoint of endpoints) {
+    const enhanced = showLiveness ? computeLiveness(endpoint, now) : { ...endpoint, status: 'healthy' as LivenessStatus, ttlRemaining: undefined };
+    
     console.log(`ID:          ${endpoint.id}`);
     console.log(`Type:        ${endpoint.type}`);
     console.log(`Coordinates: ${endpoint.coordinates}`);
+    
+    if (showLiveness) {
+      console.log(`Status:      ${getStatusIcon(enhanced.status)} ${enhanced.status}`);
+      if (enhanced.ttlRemaining !== undefined) {
+        console.log(`TTL:         ${formatTTL(enhanced.ttlRemaining)}`);
+      }
+    }
+    
     if (endpoint.metadata && Object.keys(endpoint.metadata).length > 0) {
       console.log(`Metadata:    ${JSON.stringify(endpoint.metadata)}`);
     }
@@ -371,7 +434,16 @@ async function handleEndpointsCommand(args: string[]): Promise<void> {
     const filtered = applyFilters(endpoints, filters);
     
     if (json) {
-      console.log(JSON.stringify(filtered, null, 2));
+      const now = Date.now();
+      const enhanced = filtered.map(ep => {
+        const { status, ttlRemaining } = computeLiveness(ep, now);
+        return {
+          ...ep,
+          status,
+          ttlRemaining,
+        };
+      });
+      console.log(JSON.stringify(enhanced, null, 2));
     } else {
       displayEndpoints(filtered, source);
     }
@@ -407,7 +479,20 @@ async function handleEndpointsCommand(args: string[]): Promise<void> {
     if (endpoints.length === 0) {
       console.log('No endpoints registered.');
     } else {
-      displayEndpoints(filtered, source);
+      if (json) {
+        const now = Date.now();
+        const enhanced = filtered.map(ep => {
+          const { status, ttlRemaining } = computeLiveness(ep, now);
+          return {
+            ...ep,
+            status,
+            ttlRemaining,
+          };
+        });
+        console.log(JSON.stringify(enhanced, null, 2));
+      } else {
+        displayEndpoints(filtered, source, true);
+      }
     }
 
     await new Promise((resolve) => setTimeout(resolve, interval * 1000));
diff --git a/tests/cli/mkctlEndpoints.spec.ts b/tests/cli/mkctlEndpoints.spec.ts
index 58373b5..f8c73c5 100644
--- a/tests/cli/mkctlEndpoints.spec.ts
+++ b/tests/cli/mkctlEndpoints.spec.ts
@@ -180,6 +180,66 @@ connections:
     expect(outcome.stdout).toContain('node:ep1');
     expect(outcome.stdout).not.toContain('node:ep2');
   });
+
+  it('shows liveness status in watch mode', async () => {
+    const snapshotPath = join(workspaceDir, 'reports', 'router-endpoints.json');
+    mkdirSync(join(workspaceDir, 'reports'), { recursive: true });
+    
+    const now = Date.now();
+    writeFileSync(snapshotPath, JSON.stringify([
+      { id: 'ep1', type: 'inproc', coordinates: 'node:ep1', metadata: {}, announcedAt: now, updatedAt: now, ttlMs: 30000 },
+      { id: 'ep2', type: 'inproc', coordinates: 'node:ep2', metadata: {}, announcedAt: now - 25000, updatedAt: now - 25000, ttlMs: 30000 },
+      { id: 'ep3', type: 'inproc', coordinates: 'node:ep3', metadata: {}, announcedAt: now - 35000, updatedAt: now - 35000, ttlMs: 30000 }
+    ]));
+
+    const { proc, result } = spawnMkctl(['endpoints', '--watch', '--interval', '1'], 3000);
+
+    await new Promise((resolve) => setTimeout(resolve, 1500));
+    proc.kill('SIGTERM');
+
+    const outcome = await result;
+    expect(outcome.stdout).toContain('Status:');
+    expect(outcome.stdout).toContain('TTL:');
+    expect(outcome.stdout).toMatch(/✓.*healthy|⚠.*stale|✗.*expired/);
+  });
+
+  it('includes status field in JSON output', async () => {
+    const snapshotPath = join(workspaceDir, 'reports', 'router-endpoints.json');
+    mkdirSync(join(workspaceDir, 'reports'), { recursive: true });
+    
+    const now = Date.now();
+    const testData = [
+      { id: 'ep1', type: 'inproc', coordinates: 'node:ep1', metadata: {}, announcedAt: now, updatedAt: now, ttlMs: 30000 },
+      { id: 'ep2', type: 'inproc', coordinates: 'node:ep2', metadata: {}, announcedAt: now - 25000, updatedAt: now - 25000, ttlMs: 30000 }
+    ];
+    writeFileSync(snapshotPath, JSON.stringify(testData));
+
+    const result = spawnMkctl(['endpoints', '--json']);
+    const outcome = await result.result;
+
+    expect(outcome.code).toBe(EXIT_CODES.SUCCESS);
+    const parsed = JSON.parse(outcome.stdout);
+    expect(Array.isArray(parsed)).toBe(true);
+    expect(parsed[0]).toHaveProperty('status');
+    expect(parsed[0]).toHaveProperty('ttlRemaining');
+    expect(['healthy', 'stale', 'expired']).toContain(parsed[0].status);
+  });
+
+  it('supports --runtime-dir flag', async () => {
+    const customDir = join(workspaceDir, 'custom');
+    const snapshotPath = join(customDir, 'reports', 'router-endpoints.json');
+    mkdirSync(join(customDir, 'reports'), { recursive: true });
+    
+    writeFileSync(snapshotPath, JSON.stringify([
+      { id: 'ep1', type: 'inproc', coordinates: 'node:ep1', metadata: {}, announcedAt: Date.now(), updatedAt: Date.now() }
+    ]));
+
+    const result = spawnMkctl(['endpoints', '--runtime-dir', customDir]);
+    const outcome = await result.result;
+
+    expect(outcome.code).toBe(EXIT_CODES.SUCCESS);
+    expect(outcome.stdout).toContain('node:ep1');
+  });
 });
 
 const EXIT_CODES = {
