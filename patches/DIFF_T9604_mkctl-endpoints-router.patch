diff --git a/docs/devex/stdio-path.md b/docs/devex/stdio-path.md
index 24d49e7..9929d08 100644
--- a/docs/devex/stdio-path.md
+++ b/docs/devex/stdio-path.md
@@ -118,6 +118,17 @@ npm run build
 
 # Run the StdIO echo demo
 node dist/examples/stdio-echo-demo.js
+
+# Inspecting Active StdIO Endpoints
+
+When you launch a topology with `mkctl run`, the executor now publishes endpoint announcements to the in-process RoutingServer. A snapshot is stored under `reports/router-endpoints.json`, and you can view it with:
+
+```bash
+mkctl run --file examples/configs/external-stdio.yaml --duration 2
+mkctl endpoints
+```
+
+Typical output lists endpoint IDs, coordinates, and the timestamp of the last announcement so you can confirm your StdIO adapters came online.
 ```
 
 ### Expected Output
diff --git a/scripts/mkctl.ts b/scripts/mkctl.ts
index 436ae02..3beb7e3 100644
--- a/scripts/mkctl.ts
+++ b/scripts/mkctl.ts
@@ -6,6 +6,8 @@ import { Hostess } from '../src/hostess/Hostess.js';
 import { StateManager } from '../src/state/StateManager.js';
 import { Executor } from '../src/executor/Executor.js';
 import { loadConfig } from '../src/config/loader.js';
+import { RoutingServer } from '../src/router/RoutingServer.js';
+import type { RoutingEndpoint } from '../src/types.js';
 
 const EXIT_CODES = {
   SUCCESS: 0,
@@ -67,35 +69,29 @@ async function main() {
 
   switch (cmd) {
     case 'endpoints': {
-      const snapshotPath = path.resolve(process.cwd(), 'reports', 'endpoints.json');
-      
-      let endpoints: Array<{ id: string; type: string; coordinates: string; metadata?: Record<string, any> }>;
-      try {
-        const data = await fs.readFile(snapshotPath, 'utf-8');
-        endpoints = JSON.parse(data);
-      } catch (err) {
-        console.log('No endpoints registered.');
-        break;
-      }
+      const { endpoints, source } = await loadEndpointSnapshot();
 
       if (endpoints.length === 0) {
-        console.log('No endpoints registered.');
+        console.log('No endpoints registered. (Run `mkctl run` first to generate a snapshot.)');
         break;
       }
 
-      console.log('Registered Endpoints:');
+      console.log(`Registered Endpoints (${source === 'router' ? 'RoutingServer snapshot' : 'Hostess snapshot'})`);
       console.log('');
 
       for (const endpoint of endpoints) {
         console.log(`ID:          ${endpoint.id}`);
         console.log(`Type:        ${endpoint.type}`);
         console.log(`Coordinates: ${endpoint.coordinates}`);
-        if (endpoint.metadata?.ioMode) {
-          console.log(`IO Mode:     ${endpoint.metadata.ioMode}`);
-        }
         if (endpoint.metadata && Object.keys(endpoint.metadata).length > 0) {
           console.log(`Metadata:    ${JSON.stringify(endpoint.metadata)}`);
         }
+        if (endpoint.announcedAt !== undefined) {
+          console.log(`Announced:   ${formatTimestamp(endpoint.announcedAt)}`);
+        }
+        if (endpoint.updatedAt !== undefined) {
+          console.log(`Updated:     ${formatTimestamp(endpoint.updatedAt)}`);
+        }
         console.log('');
       }
       break;
@@ -194,6 +190,77 @@ async function waitForDurationOrSignal(durationMs: number): Promise<'timer' | 's
   });
 }
 
+type EndpointSnapshot = {
+  id: string;
+  type: string;
+  coordinates: string;
+  metadata?: Record<string, any>;
+  announcedAt?: number;
+  updatedAt?: number;
+};
+
+async function loadEndpointSnapshot(): Promise<{ endpoints: EndpointSnapshot[]; source: 'router' | 'hostess' }> {
+  const routerSnapshotPath = path.resolve(process.cwd(), 'reports', 'router-endpoints.json');
+  try {
+    const raw = await fs.readFile(routerSnapshotPath, 'utf-8');
+    const parsed = JSON.parse(raw);
+    if (Array.isArray(parsed)) {
+      const endpoints = parsed.map(normalizeRouterEndpoint);
+      return { endpoints, source: 'router' };
+    }
+  } catch {
+    // fall through to hostess snapshot
+  }
+
+  const hostessSnapshotPath = path.resolve(process.cwd(), 'reports', 'endpoints.json');
+  try {
+    const raw = await fs.readFile(hostessSnapshotPath, 'utf-8');
+    const parsed = JSON.parse(raw);
+    if (Array.isArray(parsed)) {
+      const endpoints = parsed.map((entry: any) => normalizeRouterEndpoint({
+        id: entry.id,
+        type: entry.type,
+        coordinates: entry.coordinates,
+        metadata: entry.metadata,
+        announcedAt: entry.announcedAt,
+        updatedAt: entry.updatedAt,
+      }));
+      return { endpoints, source: 'hostess' };
+    }
+  } catch {
+    // ignore
+  }
+
+  return { endpoints: [], source: 'router' };
+}
+
+function normalizeRouterEndpoint(entry: any): EndpointSnapshot {
+  return {
+    id: String(entry?.id ?? ''),
+    type: String(entry?.type ?? 'unknown'),
+    coordinates: String(entry?.coordinates ?? ''),
+    metadata: entry && typeof entry.metadata === 'object' ? entry.metadata : undefined,
+    announcedAt: typeof entry?.announcedAt === 'number' ? entry.announcedAt : undefined,
+    updatedAt: typeof entry?.updatedAt === 'number' ? entry.updatedAt : undefined,
+  };
+}
+
+function formatTimestamp(value?: number): string {
+  if (value === undefined || value === null) return 'n/a';
+  const date = new Date(value);
+  if (Number.isNaN(date.getTime())) return 'n/a';
+  return date.toISOString();
+}
+
+async function writeRouterSnapshot(router: RoutingServer): Promise<void> {
+  const snapshotDir = path.resolve(process.cwd(), 'reports');
+  const snapshotPath = path.join(snapshotDir, 'router-endpoints.json');
+  await fs.mkdir(snapshotDir, { recursive: true });
+  const payload: RoutingEndpoint[] = router.list();
+  await fs.writeFile(snapshotPath, JSON.stringify(payload, null, 2), 'utf-8');
+  console.log(`[mkctl] Router endpoints captured at ${snapshotPath}`);
+}
+
 async function handleRunCommand(args: string[]): Promise<number> {
   const { configPath, durationMs } = parseRunArgs(args);
 
@@ -240,6 +307,8 @@ async function handleRunCommand(args: string[]): Promise<number> {
   const hostess = new Hostess();
   const stateManager = new StateManager(kernel);
   const executor = new Executor(kernel, hostess, stateManager);
+  const router = new RoutingServer();
+  executor.setRoutingServer(router);
 
   try {
     executor.load(config);
@@ -268,6 +337,10 @@ async function handleRunCommand(args: string[]): Promise<number> {
 
   const outcome = await waitForDurationOrSignal(durationMs);
 
+  await writeRouterSnapshot(router).catch((err) => {
+    logError(`Failed to write router snapshot: ${err instanceof Error ? err.message : String(err)}`);
+  });
+
   console.log('\nBringing topology down...');
   try {
     await executor.down();
