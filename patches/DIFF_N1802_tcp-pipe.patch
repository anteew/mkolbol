diff --git a/examples/network/remote-viewer/README.md b/examples/network/remote-viewer/README.md
new file mode 100644
index 0000000..2d48d39
--- /dev/null
+++ b/examples/network/remote-viewer/README.md
@@ -0,0 +1,54 @@
+# Remote Viewer Example
+
+Demonstrates TCP-based remote streaming using TCPPipe adapter.
+
+## Architecture
+
+```
+Process A (Server)          Process B (Client)
+┌─────────────────┐        ┌─────────────────┐
+│  TimerSource    │        │                 │
+│       ↓         │        │                 │
+│  TCPPipeServer  │────────│  TCPPipeClient  │
+│  (port 30018)   │  TCP   │       ↓         │
+└─────────────────┘        │   stdout        │
+                           └─────────────────┘
+```
+
+## Running
+
+**Terminal 1 (Server):**
+```bash
+npm run build
+npx tsx examples/network/remote-viewer/server.ts
+```
+
+**Terminal 2 (Client):**
+```bash
+npx tsx examples/network/remote-viewer/client.ts
+```
+
+**Expected Output (Client):**
+```
+[Client] Connecting to server on port 30018...
+[Client] Connected! Receiving data:
+
+[Client] Server message
+[Client] Server message
+[Client] Server message
+...
+```
+
+Press Ctrl+C in either terminal to stop.
+
+## Features Demonstrated
+
+- **Cross-process streaming** - Data flows over TCP between processes
+- **Frame-based protocol** - Length-prefixed frames with metadata
+- **Bidirectional communication** - Both client and server can send/receive
+- **Graceful shutdown** - Clean connection termination
+- **Ping/pong keep-alive** - Automatic heartbeat (handled by codec)
+
+## Port Usage
+
+Uses ephemeral port **30018** (range 30010-30019) to avoid collisions.
diff --git a/examples/network/remote-viewer/client.ts b/examples/network/remote-viewer/client.ts
new file mode 100644
index 0000000..eac7d5d
--- /dev/null
+++ b/examples/network/remote-viewer/client.ts
@@ -0,0 +1,33 @@
+#!/usr/bin/env tsx
+import { TCPPipeClient } from '../../../src/pipes/adapters/TCPPipe.js';
+
+console.log('[Client] Connecting to server on port 30018...');
+
+const client = new TCPPipeClient({ port: 30018 });
+
+client.connect().then(() => {
+  console.log('[Client] Connected! Receiving data:\n');
+
+  client.on('data', (chunk: Buffer) => {
+    process.stdout.write(`[Client] ${chunk.toString('utf8')}\n`);
+  });
+
+  client.on('end', () => {
+    console.log('\n[Client] Connection closed');
+    process.exit(0);
+  });
+
+  client.on('error', (err) => {
+    console.error('[Client] Error:', err);
+    process.exit(1);
+  });
+}).catch((err) => {
+  console.error('[Client] Failed to connect:', err);
+  process.exit(1);
+});
+
+process.on('SIGINT', () => {
+  console.log('\n[Client] Disconnecting...');
+  client.close();
+  process.exit(0);
+});
diff --git a/examples/network/remote-viewer/server.ts b/examples/network/remote-viewer/server.ts
new file mode 100644
index 0000000..50d4c7f
--- /dev/null
+++ b/examples/network/remote-viewer/server.ts
@@ -0,0 +1,31 @@
+#!/usr/bin/env tsx
+import { Kernel } from '../../../src/kernel/Kernel.js';
+import { TimerSource } from '../../../src/modules/timer.js';
+import { TCPPipeServer } from '../../../src/pipes/adapters/TCPPipe.js';
+
+const kernel = new Kernel();
+const timer = new TimerSource(kernel, 1000, 'Server message');
+const tcpServer = new TCPPipeServer({ port: 30018 });
+
+console.log('[Server] Starting timer source...');
+timer.start();
+
+console.log('[Server] Listening on TCP port 30018...');
+tcpServer.listen((clientStream) => {
+  console.log('[Server] Client connected, streaming data...');
+  
+  timer.outputPipe.pipe(clientStream);
+  
+  clientStream.on('end', () => {
+    console.log('[Server] Client disconnected');
+  });
+});
+
+process.on('SIGINT', async () => {
+  console.log('\n[Server] Shutting down...');
+  timer.stop();
+  await tcpServer.close();
+  process.exit(0);
+});
+
+console.log('[Server] Press Ctrl+C to stop');
diff --git a/src/pipes/adapters/TCPPipe.ts b/src/pipes/adapters/TCPPipe.ts
new file mode 100644
index 0000000..dcc2154
--- /dev/null
+++ b/src/pipes/adapters/TCPPipe.ts
@@ -0,0 +1,240 @@
+import { Duplex } from 'stream';
+import { Socket, createServer, Server } from 'net';
+import { FrameCodec } from '../../net/frame.js';
+import type { Frame } from '../../net/transport.js';
+import { debug } from '../../debug/api.js';
+
+export interface TCPPipeOptions {
+  host?: string;
+  port: number;
+  objectMode?: boolean;
+  timeout?: number;
+}
+
+export class TCPPipeClient extends Duplex {
+  private socket?: Socket;
+  private buffer: Buffer = Buffer.alloc(0);
+  private sequenceId = 0;
+
+  constructor(private options: TCPPipeOptions) {
+    super({ objectMode: options.objectMode ?? false });
+  }
+
+  connect(): Promise<void> {
+    return new Promise((resolve, reject) => {
+      const host = this.options.host || 'localhost';
+      const port = this.options.port;
+
+      this.socket = new Socket();
+
+      if (this.options.timeout) {
+        this.socket.setTimeout(this.options.timeout);
+      }
+
+      this.socket.on('connect', () => {
+        debug.emit('tcp-pipe', 'client.connect', { host, port }, 'info');
+        resolve();
+      });
+
+      this.socket.on('data', (chunk: Buffer) => {
+        this.handleIncomingData(chunk);
+      });
+
+      this.socket.on('error', (err) => {
+        debug.emit('tcp-pipe', 'client.error', { error: err.message }, 'error');
+        reject(err);
+      });
+
+      this.socket.on('close', () => {
+        debug.emit('tcp-pipe', 'client.close', {}, 'info');
+        this.push(null);
+      });
+
+      this.socket.connect(port, host);
+    });
+  }
+
+  _write(chunk: any, encoding: BufferEncoding, callback: (error?: Error | null) => void): void {
+    if (!this.socket) {
+      callback(new Error('Not connected'));
+      return;
+    }
+
+    try {
+      const frame = FrameCodec.createDataFrame(chunk, this.sequenceId++);
+      const encoded = FrameCodec.encode(frame);
+      this.socket.write(encoded, callback);
+    } catch (err) {
+      callback(err as Error);
+    }
+  }
+
+  _read(size: number): void {
+    // Backpressure handled by socket
+  }
+
+  private handleIncomingData(chunk: Buffer): void {
+    this.buffer = Buffer.concat([this.buffer, chunk]);
+
+    while (this.buffer.length > 0) {
+      const result = FrameCodec.decode(this.buffer);
+
+      if (!result) {
+        break;
+      }
+
+      const { frame, bytesConsumed } = result;
+      this.buffer = this.buffer.slice(bytesConsumed);
+
+      if (frame.metadata.type === 'data') {
+        this.push(frame.payload);
+      } else if (frame.metadata.type === 'ping') {
+        this.sendPong();
+      } else if (frame.metadata.type === 'close') {
+        this.push(null);
+      }
+    }
+  }
+
+  private sendPong(): void {
+    if (this.socket) {
+      const pong = FrameCodec.createPongFrame();
+      const encoded = FrameCodec.encode(pong);
+      this.socket.write(encoded);
+    }
+  }
+
+  close(): void {
+    if (this.socket) {
+      const closeFrame = FrameCodec.createCloseFrame();
+      const encoded = FrameCodec.encode(closeFrame);
+      this.socket.write(encoded, () => {
+        this.socket?.end();
+      });
+    }
+  }
+
+  _final(callback: (error?: Error | null) => void): void {
+    this.close();
+    callback();
+  }
+}
+
+export class TCPPipeServer {
+  private server?: Server;
+  private connections: Set<Socket> = new Set();
+
+  constructor(private options: TCPPipeOptions) {}
+
+  listen(callback: (stream: Duplex) => void): Promise<number> {
+    return new Promise((resolve, reject) => {
+      const port = this.options.port;
+
+      this.server = createServer((socket) => {
+        debug.emit('tcp-pipe', 'server.connection', { remoteAddress: socket.remoteAddress }, 'info');
+        this.connections.add(socket);
+
+        const pipe = new TCPServerPipe(socket);
+        callback(pipe);
+
+        socket.on('close', () => {
+          this.connections.delete(socket);
+        });
+      });
+
+      this.server.on('error', (err) => {
+        debug.emit('tcp-pipe', 'server.error', { error: err.message }, 'error');
+        reject(err);
+      });
+
+      this.server.listen(port, () => {
+        const address = this.server!.address();
+        const actualPort = (address && typeof address === 'object') ? address.port : port;
+        debug.emit('tcp-pipe', 'server.listen', { port: actualPort }, 'info');
+        resolve(actualPort);
+      });
+    });
+  }
+
+  close(): Promise<void> {
+    return new Promise((resolve) => {
+      for (const socket of this.connections) {
+        socket.end();
+      }
+      this.connections.clear();
+
+      if (this.server) {
+        this.server.close(() => {
+          debug.emit('tcp-pipe', 'server.close', {}, 'info');
+          resolve();
+        });
+      } else {
+        resolve();
+      }
+    });
+  }
+}
+
+class TCPServerPipe extends Duplex {
+  private buffer: Buffer = Buffer.alloc(0);
+  private sequenceId = 0;
+
+  constructor(private socket: Socket) {
+    super({ objectMode: false });
+
+    socket.on('data', (chunk: Buffer) => {
+      this.handleIncomingData(chunk);
+    });
+
+    socket.on('close', () => {
+      this.push(null);
+    });
+
+    socket.on('error', (err) => {
+      this.emit('error', err);
+    });
+  }
+
+  _write(chunk: any, encoding: BufferEncoding, callback: (error?: Error | null) => void): void {
+    try {
+      const frame = FrameCodec.createDataFrame(chunk, this.sequenceId++);
+      const encoded = FrameCodec.encode(frame);
+      this.socket.write(encoded, callback);
+    } catch (err) {
+      callback(err as Error);
+    }
+  }
+
+  _read(size: number): void {
+    // Backpressure handled by socket
+  }
+
+  private handleIncomingData(chunk: Buffer): void {
+    this.buffer = Buffer.concat([this.buffer, chunk]);
+
+    while (this.buffer.length > 0) {
+      const result = FrameCodec.decode(this.buffer);
+
+      if (!result) {
+        break;
+      }
+
+      const { frame, bytesConsumed } = result;
+      this.buffer = this.buffer.slice(bytesConsumed);
+
+      if (frame.metadata.type === 'data') {
+        this.push(frame.payload);
+      } else if (frame.metadata.type === 'ping') {
+        this.sendPong();
+      } else if (frame.metadata.type === 'close') {
+        this.push(null);
+      }
+    }
+  }
+
+  private sendPong(): void {
+    const pong = FrameCodec.createPongFrame();
+    const encoded = FrameCodec.encode(pong);
+    this.socket.write(encoded);
+  }
+}
diff --git a/tests/integration/tcpPipe.spec.ts b/tests/integration/tcpPipe.spec.ts
new file mode 100644
index 0000000..e50483d
--- /dev/null
+++ b/tests/integration/tcpPipe.spec.ts
@@ -0,0 +1,172 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import { TCPPipeClient, TCPPipeServer } from '../../src/pipes/adapters/TCPPipe.js';
+
+describe('TCPPipe', () => {
+  let server: TCPPipeServer;
+  let client: TCPPipeClient;
+  let serverPort: number;
+
+  afterEach(async () => {
+    if (client) {
+      client.close();
+    }
+    if (server) {
+      await server.close();
+    }
+  });
+
+  it('establishes connection and sends data', async () => {
+    server = new TCPPipeServer({ port: 30010 });
+    
+    const serverData: Buffer[] = [];
+    await server.listen((stream) => {
+      stream.on('data', (chunk) => {
+        serverData.push(chunk);
+      });
+    });
+
+    client = new TCPPipeClient({ port: 30010 });
+    await client.connect();
+
+    client.write('hello from client');
+    client.end();
+
+    await new Promise((resolve) => setTimeout(resolve, 200));
+
+    const received = Buffer.concat(serverData).toString('utf8');
+    expect(received).toBe('hello from client');
+  });
+
+  it('bidirectional data flow', async () => {
+    server = new TCPPipeServer({ port: 30011 });
+    
+    let serverStream: any;
+    await server.listen((stream) => {
+      serverStream = stream;
+      stream.on('data', (chunk) => {
+        stream.write(`echo: ${chunk.toString('utf8')}`);
+      });
+    });
+
+    client = new TCPPipeClient({ port: 30011 });
+    await client.connect();
+
+    const clientData: Buffer[] = [];
+    client.on('data', (chunk) => {
+      clientData.push(chunk);
+    });
+
+    client.write('test message');
+
+    await new Promise((resolve) => setTimeout(resolve, 200));
+
+    const received = Buffer.concat(clientData).toString('utf8');
+    expect(received).toBe('echo: test message');
+  });
+
+  it('handles multiple sequential messages', async () => {
+    server = new TCPPipeServer({ port: 30012 });
+    
+    const serverData: string[] = [];
+    await server.listen((stream) => {
+      stream.on('data', (chunk) => {
+        serverData.push(chunk.toString('utf8'));
+      });
+    });
+
+    client = new TCPPipeClient({ port: 30012 });
+    await client.connect();
+
+    client.write('msg1');
+    client.write('msg2');
+    client.write('msg3');
+    client.end();
+
+    await new Promise((resolve) => setTimeout(resolve, 200));
+
+    expect(serverData).toEqual(['msg1', 'msg2', 'msg3']);
+  });
+
+  it('handles ping/pong keep-alive', async () => {
+    server = new TCPPipeServer({ port: 30013 });
+    await server.listen((stream) => {
+      // Server automatically responds to pings
+    });
+
+    client = new TCPPipeClient({ port: 30013 });
+    await client.connect();
+
+    // Send ping (handled internally by codec)
+    expect(client).toBeDefined();
+  });
+
+  it('handles large payloads', async () => {
+    server = new TCPPipeServer({ port: 30014 });
+    
+    const serverData: Buffer[] = [];
+    await server.listen((stream) => {
+      stream.on('data', (chunk) => {
+        serverData.push(chunk);
+      });
+    });
+
+    client = new TCPPipeClient({ port: 30014 });
+    await client.connect();
+
+    const largeData = Buffer.alloc(1024 * 512, 'x'); // 512KB
+    client.write(largeData);
+    client.end();
+
+    await new Promise((resolve) => setTimeout(resolve, 500));
+
+    const received = Buffer.concat(serverData);
+    expect(received.length).toBe(largeData.length);
+    expect(received.equals(largeData)).toBe(true);
+  });
+
+  it('handles connection errors gracefully', async () => {
+    client = new TCPPipeClient({ port: 30015, timeout: 1000 });
+
+    try {
+      await client.connect();
+      expect.fail('Should have thrown connection error');
+    } catch (err) {
+      expect(err).toBeDefined();
+    }
+  });
+
+  it('server accepts multiple clients', async () => {
+    server = new TCPPipeServer({ port: 30016 });
+    
+    let connectionCount = 0;
+    await server.listen((stream) => {
+      connectionCount++;
+    });
+
+    const client1 = new TCPPipeClient({ port: 30016 });
+    const client2 = new TCPPipeClient({ port: 30016 });
+
+    await client1.connect();
+    await client2.connect();
+
+    await new Promise((resolve) => setTimeout(resolve, 100));
+
+    expect(connectionCount).toBe(2);
+
+    client1.close();
+    client2.close();
+  });
+
+  it('closes cleanly', async () => {
+    server = new TCPPipeServer({ port: 30017 });
+    await server.listen((stream) => {});
+
+    client = new TCPPipeClient({ port: 30017 });
+    await client.connect();
+
+    client.close();
+    await server.close();
+
+    expect(true).toBe(true);
+  });
+});
