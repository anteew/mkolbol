diff --git a/src/transforms/AnsiParser.ts b/src/transforms/AnsiParser.ts
index 4a13143..cdd7ffb 100644
--- a/src/transforms/AnsiParser.ts
+++ b/src/transforms/AnsiParser.ts
@@ -46,6 +46,9 @@ export interface AnsiParserOptions {
   scrollbackLimit?: number;
   cols?: number;
   rows?: number;
+  oscMaxLength?: number;
+  oscTimeoutMs?: number;
+  maxParseIterations?: number;
 }
 
 export interface ScrollbackLine {
@@ -151,11 +154,18 @@ export class AnsiParser {
   private currentLineStyle: AnsiParserState;
   private cols: number;
   private rows: number;
+  private oscMaxLength: number;
+  private oscTimeoutMs: number;
+  private maxParseIterations: number;
+  private parseStartTime: number = 0;
 
   constructor(options: AnsiParserOptions = {}) {
     this.scrollbackLimit = options.scrollbackLimit ?? 1000;
     this.cols = Math.max(1, Math.floor(options.cols ?? 80));
     this.rows = Math.max(1, Math.floor(options.rows ?? 24));
+    this.oscMaxLength = options.oscMaxLength ?? 100000;
+    this.oscTimeoutMs = options.oscTimeoutMs ?? 5000;
+    this.maxParseIterations = options.maxParseIterations ?? 1000000;
     this.state = this.createInitialState();
     this.currentLineStyle = { ...this.state };
   }
@@ -178,9 +188,23 @@ export class AnsiParser {
     this.events.length = 0;
     this.buffer = input;
     this.charBatch = '';
+    this.parseStartTime = Date.now();
     let i = 0;
+    let iterations = 0;
 
     while (i < this.buffer.length) {
+      // Performance guard: prevent infinite loops
+      if (++iterations > this.maxParseIterations) {
+        this.flushCharBatch();
+        break;
+      }
+
+      // Performance guard: prevent long-running parsing
+      if (Date.now() - this.parseStartTime > this.oscTimeoutMs) {
+        this.flushCharBatch();
+        break;
+      }
+
       const charCode = this.buffer.charCodeAt(i);
 
       if (charCode === 0x1B) {
@@ -299,8 +323,21 @@ export class AnsiParser {
 
   private parseOSC(startIndex: number): number {
     let i = startIndex;
+    const oscStart = startIndex;
 
     while (i < this.buffer.length) {
+      // Guard: Prevent OSC payload DOS attacks
+      const oscLength = i - oscStart;
+      if (oscLength > this.oscMaxLength) {
+        // Abort this OSC sequence and skip to end marker or limit
+        return oscLength + 2;
+      }
+
+      // Guard: Timeout check for incomplete sequences
+      if (Date.now() - this.parseStartTime > this.oscTimeoutMs) {
+        return i - startIndex + 2;
+      }
+
       const char = this.buffer[i];
       if (char === '\x07' || (char === '\x1B' && this.buffer[i + 1] === '\\')) {
         return i - startIndex + (char === '\x07' ? 3 : 4);
diff --git a/tests/transforms/ansiParser.performance.spec.ts b/tests/transforms/ansiParser.performance.spec.ts
index d37b2b1..a449368 100644
--- a/tests/transforms/ansiParser.performance.spec.ts
+++ b/tests/transforms/ansiParser.performance.spec.ts
@@ -6,6 +6,9 @@ import type { AnsiParserEvent } from '../../src/transforms/AnsiParser.js';
 const countStyleEvents = (events: AnsiParserEvent[]) =>
   events.filter(event => event.type === 'style').length;
 
+const countPrintEvents = (events: AnsiParserEvent[]) =>
+  events.filter(event => event.type === 'print').length;
+
 describe('AnsiParser performance guards', () => {
   it('processes extended palette sequences within budget', () => {
     const parser = new AnsiParser();
@@ -30,4 +33,111 @@ describe('AnsiParser performance guards', () => {
     expect(countStyleEvents(events)).toBe(200);
     expect(duration).toBeLessThan(75);
   });
+
+  describe('OSC handling robustness', () => {
+    it('limits large OSC payload to prevent DOS', () => {
+      const parser = new AnsiParser({ oscMaxLength: 1000 });
+      const largePayload = '\x1b]0;' + 'A'.repeat(5000) + '\x07';
+
+      const start = performance.now();
+      const events = parser.parse(largePayload);
+      const duration = performance.now() - start;
+
+      expect(duration).toBeLessThan(100);
+      expect(events.length).toBeGreaterThanOrEqual(0);
+    });
+
+    it('handles incomplete OSC sequences gracefully', () => {
+      const parser = new AnsiParser();
+      const incomplete = '\x1b]0;Title without terminator';
+
+      const events = parser.parse(incomplete);
+      expect(events.length).toBeGreaterThanOrEqual(0);
+    });
+
+    it('handles nested escape sequences', () => {
+      const parser = new AnsiParser();
+      const nested = '\x1b]0;Title\x1b[31m\x07Text';
+
+      const start = performance.now();
+      const events = parser.parse(nested);
+      const duration = performance.now() - start;
+
+      expect(duration).toBeLessThan(50);
+      expect(events.length).toBeGreaterThan(0);
+    });
+
+    it('handles malformed OSC input', () => {
+      const parser = new AnsiParser();
+      const malformed = '\x1b]\x1b]\x1b]0;Bad\x07';
+
+      const events = parser.parse(malformed);
+      expect(events.length).toBeGreaterThanOrEqual(0);
+    });
+
+    it('handles very long OSC sequences with proper termination', () => {
+      const parser = new AnsiParser({ oscMaxLength: 200000 });
+      const longOsc = '\x1b]0;' + 'Title'.repeat(10000) + '\x07Normal text';
+
+      const start = performance.now();
+      const events = parser.parse(longOsc);
+      const duration = performance.now() - start;
+
+      expect(duration).toBeLessThan(200);
+      expect(countPrintEvents(events)).toBeGreaterThan(0);
+    });
+
+    it('prevents timeout on pathological input', () => {
+      const parser = new AnsiParser({ oscTimeoutMs: 100, maxParseIterations: 50000 });
+      const pathological = '\x1b]0;' + 'A'.repeat(200000);
+
+      const start = performance.now();
+      const events = parser.parse(pathological);
+      const duration = performance.now() - start;
+
+      expect(duration).toBeLessThan(150);
+    });
+
+    it('handles multiple OSC sequences efficiently', () => {
+      const parser = new AnsiParser();
+      const multiple = Array.from({ length: 100 }, (_, i) => 
+        `\x1b]0;Title${i}\x07Text${i}`
+      ).join('');
+
+      const start = performance.now();
+      const events = parser.parse(multiple);
+      const duration = performance.now() - start;
+
+      expect(duration).toBeLessThan(100);
+      expect(countPrintEvents(events)).toBeGreaterThan(0);
+    });
+
+    it('respects maxParseIterations guard', () => {
+      const parser = new AnsiParser({ maxParseIterations: 1000 });
+      const large = 'A'.repeat(10000);
+
+      const start = performance.now();
+      const events = parser.parse(large);
+      const duration = performance.now() - start;
+
+      expect(duration).toBeLessThan(50);
+      expect(events.length).toBeGreaterThanOrEqual(0);
+    });
+
+    it('handles OSC with ST terminator', () => {
+      const parser = new AnsiParser();
+      const oscST = '\x1b]0;Title\x1b\\Normal text';
+
+      const events = parser.parse(oscST);
+      expect(countPrintEvents(events)).toBeGreaterThan(0);
+    });
+
+    it('handles mixed OSC terminators', () => {
+      const parser = new AnsiParser();
+      const mixed = '\x1b]0;First\x07\x1b]1;Second\x1b\\Text';
+
+      const events = parser.parse(mixed);
+      expect(countPrintEvents(events)).toBeGreaterThan(0);
+    });
+  });
 });
