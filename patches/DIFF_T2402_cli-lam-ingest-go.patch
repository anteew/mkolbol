diff --git a/scripts/ingest-go.ts b/scripts/ingest-go.ts
new file mode 100644
index 0000000..4d4ab99
--- /dev/null
+++ b/scripts/ingest-go.ts
@@ -0,0 +1,131 @@
+import * as fs from 'node:fs';
+import * as path from 'node:path';
+
+export interface GoTestEvent {
+  Time?: string;
+  Action?: string;
+  Package?: string;
+  Test?: string;
+  Output?: string;
+  Elapsed?: number;
+}
+
+export interface LaminarTestEvent {
+  ts: number;
+  lvl: string;
+  case?: string;
+  phase?: string;
+  evt: string;
+  payload?: any;
+}
+
+export function parseGoTestJSON(input: string): GoTestEvent[] {
+  return input
+    .trim()
+    .split('\n')
+    .filter(line => line.trim())
+    .map(line => {
+      try {
+        return JSON.parse(line) as GoTestEvent;
+      } catch {
+        return null;
+      }
+    })
+    .filter((e): e is GoTestEvent => e !== null);
+}
+
+export function convertToLaminar(events: GoTestEvent[]): {
+  events: LaminarTestEvent[];
+  summary: Array<{ status: string; duration: number; location: string; artifactURI: string }>;
+} {
+  const laminarEvents: LaminarTestEvent[] = [];
+  const summary: Array<{ status: string; duration: number; location: string; artifactURI: string }> = [];
+  const testCases = new Map<string, { start?: number; pkg: string }>();
+
+  for (const evt of events) {
+    const ts = evt.Time ? new Date(evt.Time).getTime() : Date.now();
+    const caseId = evt.Test ? `${evt.Package}/${evt.Test}` : evt.Package;
+
+    if (evt.Action === 'run' && evt.Test) {
+      testCases.set(caseId!, { start: ts, pkg: evt.Package! });
+      laminarEvents.push({
+        ts,
+        lvl: 'info',
+        case: caseId,
+        phase: 'run',
+        evt: 'test.start',
+        payload: { package: evt.Package, test: evt.Test }
+      });
+    } else if (evt.Action === 'output' && evt.Output) {
+      laminarEvents.push({
+        ts,
+        lvl: 'info',
+        case: caseId,
+        phase: 'run',
+        evt: 'test.output',
+        payload: { output: evt.Output.trim() }
+      });
+    } else if ((evt.Action === 'pass' || evt.Action === 'fail' || evt.Action === 'skip') && evt.Test) {
+      const testData = testCases.get(caseId!);
+      const duration = evt.Elapsed ? Math.round(evt.Elapsed * 1000) : 0;
+      
+      laminarEvents.push({
+        ts,
+        lvl: evt.Action === 'fail' ? 'error' : 'info',
+        case: caseId,
+        phase: 'complete',
+        evt: `test.${evt.Action}`,
+        payload: { package: evt.Package, test: evt.Test, elapsed: evt.Elapsed }
+      });
+
+      const location = `${evt.Package}/${evt.Test}`;
+      const artifactURI = `reports/${location.replace(/\//g, '.')}.jsonl`;
+      
+      summary.push({
+        status: evt.Action,
+        duration,
+        location,
+        artifactURI
+      });
+    }
+  }
+
+  return { events: laminarEvents, summary };
+}
+
+export function writeOutput(
+  laminarEvents: LaminarTestEvent[],
+  summary: Array<{ status: string; duration: number; location: string; artifactURI: string }>
+): void {
+  fs.mkdirSync('reports', { recursive: true });
+
+  const caseGroups = new Map<string, LaminarTestEvent[]>();
+  for (const evt of laminarEvents) {
+    if (evt.case) {
+      if (!caseGroups.has(evt.case)) {
+        caseGroups.set(evt.case, []);
+      }
+      caseGroups.get(evt.case)!.push(evt);
+    }
+  }
+
+  for (const [caseId, events] of caseGroups) {
+    const artifactPath = `reports/${caseId.replace(/\//g, '.')}.jsonl`;
+    const dir = path.dirname(artifactPath);
+    fs.mkdirSync(dir, { recursive: true });
+    fs.writeFileSync(artifactPath, events.map(e => JSON.stringify(e)).join('\n') + '\n');
+  }
+
+  const summaryPath = 'reports/summary.jsonl';
+  fs.writeFileSync(summaryPath, summary.map(s => JSON.stringify(s)).join('\n') + '\n');
+}
+
+export function ingestGoTest(input: string): void {
+  const goEvents = parseGoTestJSON(input);
+  const { events, summary } = convertToLaminar(goEvents);
+  writeOutput(events, summary);
+  
+  console.log(`Ingested ${goEvents.length} go test events`);
+  console.log(`Generated ${summary.length} test case summaries`);
+  console.log(`Wrote artifacts to reports/`);
+}
diff --git a/scripts/lam.ts b/scripts/lam.ts
index 2766944..ac72ec5 100644
--- a/scripts/lam.ts
+++ b/scripts/lam.ts
@@ -1,6 +1,7 @@
 #!/usr/bin/env node
-import { spawnSync } from 'node:child_process';
+import { spawnSync, execSync } from 'node:child_process';
 import * as fs from 'node:fs';
+import { ingestGoTest } from './ingest-go.js';
 
 function sh(cmd: string, args: string[], env: Record<string, string> = {}) {
   const res = spawnSync(cmd, args, { stdio: 'inherit', env: { ...process.env, ...env } });
@@ -15,6 +16,7 @@ Usage:
   lam summary
   lam show --case <suite/case> [--around <pattern>] [--window <n>]
   lam digest [--cases <case1,case2,...>]
+  lam ingest --go [--from-file <path> | --cmd "<command>"]
   lam rules get
   lam rules set --file <path> | --inline '<json>'
 
@@ -24,6 +26,8 @@ Examples:
   lam show --case kernel.spec/connect_moves_data_1_1 --around assert.fail --window 50
   lam digest
   lam digest --cases kernel.spec/connect_moves_data_1_1,kernel.spec/another_case
+  lam ingest --go --from-file go-test-output.json
+  lam ingest --go --cmd "go test -json ./..."
   lam rules get
   lam rules set --inline '{"budget":{"kb":2}}'
 `);
@@ -106,6 +110,49 @@ async function main() {
       }
       break;
     }
+    case 'ingest': {
+      const go = args.get('go');
+      if (!go) {
+        console.error('lam ingest --go [--from-file <path> | --cmd "<command>"]');
+        process.exit(1);
+      }
+      
+      const fromFile = args.get('from-file') as string | undefined;
+      const cmd = args.get('cmd') as string | undefined;
+      
+      if (!fromFile && !cmd) {
+        console.error('lam ingest --go requires --from-file <path> or --cmd "<command>"');
+        process.exit(1);
+      }
+      
+      if (fromFile && cmd) {
+        console.error('lam ingest --go: use either --from-file or --cmd, not both');
+        process.exit(1);
+      }
+      
+      let input: string;
+      if (fromFile) {
+        if (!fs.existsSync(fromFile)) {
+          console.error(`File not found: ${fromFile}`);
+          process.exit(1);
+        }
+        input = fs.readFileSync(fromFile, 'utf-8');
+      } else {
+        try {
+          input = execSync(cmd!, { encoding: 'utf-8', maxBuffer: 10 * 1024 * 1024 });
+        } catch (error: any) {
+          input = error.stdout || '';
+          if (!input) {
+            console.error(`Command failed: ${cmd}`);
+            console.error(error.message);
+            process.exit(1);
+          }
+        }
+      }
+      
+      ingestGoTest(input);
+      break;
+    }
     case 'rules': {
       const sub = rest[0];
       if (sub === 'get') {
