diff --git a/dist/digest/fingerprint.d.ts b/dist/digest/fingerprint.d.ts
new file mode 100644
index 0000000..05b4d21
--- /dev/null
+++ b/dist/digest/fingerprint.d.ts
@@ -0,0 +1,22 @@
+export interface FailureInfo {
+    testName: string;
+    errorType?: string;
+    stackLocation?: string;
+    errorMessage?: string;
+}
+export interface HistoryEntry {
+    timestamp: string;
+    fingerprint: string;
+    testName: string;
+    status: 'pass' | 'fail' | 'skip';
+    duration: number;
+    location: string;
+    runMetadata?: {
+        seed?: string;
+        runId?: string;
+        [key: string]: any;
+    };
+}
+export declare function generateFingerprint(failure: FailureInfo): string;
+export declare function extractFailureInfo(testName: string, error?: string, payload?: any): FailureInfo;
+//# sourceMappingURL=fingerprint.d.ts.map
\ No newline at end of file
diff --git a/dist/digest/fingerprint.d.ts.map b/dist/digest/fingerprint.d.ts.map
new file mode 100644
index 0000000..abab68b
--- /dev/null
+++ b/dist/digest/fingerprint.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"fingerprint.d.ts","sourceRoot":"","sources":["../../src/digest/fingerprint.ts"],"names":[],"mappings":"AAEA,MAAM,WAAW,WAAW;IAC1B,QAAQ,EAAE,MAAM,CAAC;IACjB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,aAAa,CAAC,EAAE,MAAM,CAAC;IACvB,YAAY,CAAC,EAAE,MAAM,CAAC;CACvB;AAED,MAAM,WAAW,YAAY;IAC3B,SAAS,EAAE,MAAM,CAAC;IAClB,WAAW,EAAE,MAAM,CAAC;IACpB,QAAQ,EAAE,MAAM,CAAC;IACjB,MAAM,EAAE,MAAM,GAAG,MAAM,GAAG,MAAM,CAAC;IACjC,QAAQ,EAAE,MAAM,CAAC;IACjB,QAAQ,EAAE,MAAM,CAAC;IACjB,WAAW,CAAC,EAAE;QACZ,IAAI,CAAC,EAAE,MAAM,CAAC;QACd,KAAK,CAAC,EAAE,MAAM,CAAC;QACf,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;KACpB,CAAC;CACH;AAED,wBAAgB,mBAAmB,CAAC,OAAO,EAAE,WAAW,GAAG,MAAM,CAahE;AAED,wBAAgB,kBAAkB,CAChC,QAAQ,EAAE,MAAM,EAChB,KAAK,CAAC,EAAE,MAAM,EACd,OAAO,CAAC,EAAE,GAAG,GACZ,WAAW,CAkCb"}
\ No newline at end of file
diff --git a/dist/digest/fingerprint.js b/dist/digest/fingerprint.js
new file mode 100644
index 0000000..3b3cba1
--- /dev/null
+++ b/dist/digest/fingerprint.js
@@ -0,0 +1,40 @@
+import * as crypto from 'node:crypto';
+export function generateFingerprint(failure) {
+    const parts = [failure.testName];
+    if (failure.errorType) {
+        parts.push(failure.errorType);
+    }
+    if (failure.stackLocation) {
+        parts.push(failure.stackLocation);
+    }
+    const content = parts.join('::');
+    return crypto.createHash('sha256').update(content).digest('hex').substring(0, 16);
+}
+export function extractFailureInfo(testName, error, payload) {
+    const info = { testName };
+    if (error) {
+        info.errorMessage = error;
+        const errorTypeMatch = error.match(/^(\w+Error)/);
+        if (errorTypeMatch) {
+            info.errorType = errorTypeMatch[1];
+        }
+    }
+    if (payload && typeof payload === 'object') {
+        if ('stack' in payload && typeof payload.stack === 'string') {
+            const stackLines = payload.stack.split('\n');
+            const firstRelevantLine = stackLines.find((line) => line.includes('.spec.ts') || line.includes('.test.ts'));
+            if (firstRelevantLine) {
+                const match = firstRelevantLine.match(/\(([^)]+):(\d+):(\d+)\)/) ||
+                    firstRelevantLine.match(/at ([^:]+):(\d+):(\d+)/);
+                if (match) {
+                    info.stackLocation = `${match[1]}:${match[2]}`;
+                }
+            }
+        }
+        if ('name' in payload && typeof payload.name === 'string') {
+            info.errorType = payload.name;
+        }
+    }
+    return info;
+}
+//# sourceMappingURL=fingerprint.js.map
\ No newline at end of file
diff --git a/dist/digest/fingerprint.js.map b/dist/digest/fingerprint.js.map
new file mode 100644
index 0000000..7340af2
--- /dev/null
+++ b/dist/digest/fingerprint.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"fingerprint.js","sourceRoot":"","sources":["../../src/digest/fingerprint.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,MAAM,aAAa,CAAC;AAuBtC,MAAM,UAAU,mBAAmB,CAAC,OAAoB;IACtD,MAAM,KAAK,GAAa,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;IAE3C,IAAI,OAAO,CAAC,SAAS,EAAE,CAAC;QACtB,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAChC,CAAC;IAED,IAAI,OAAO,CAAC,aAAa,EAAE,CAAC;QAC1B,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;IACpC,CAAC;IAED,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACjC,OAAO,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AACpF,CAAC;AAED,MAAM,UAAU,kBAAkB,CAChC,QAAgB,EAChB,KAAc,EACd,OAAa;IAEb,MAAM,IAAI,GAAgB,EAAE,QAAQ,EAAE,CAAC;IAEvC,IAAI,KAAK,EAAE,CAAC;QACV,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;QAE1B,MAAM,cAAc,GAAG,KAAK,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;QAClD,IAAI,cAAc,EAAE,CAAC;YACnB,IAAI,CAAC,SAAS,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;QACrC,CAAC;IACH,CAAC;IAED,IAAI,OAAO,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,CAAC;QAC3C,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,KAAK,KAAK,QAAQ,EAAE,CAAC;YAC5D,MAAM,UAAU,GAAG,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YAC7C,MAAM,iBAAiB,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC,IAAY,EAAE,EAAE,CACzD,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CACvD,CAAC;YAEF,IAAI,iBAAiB,EAAE,CAAC;gBACtB,MAAM,KAAK,GAAG,iBAAiB,CAAC,KAAK,CAAC,yBAAyB,CAAC;oBAClD,iBAAiB,CAAC,KAAK,CAAC,wBAAwB,CAAC,CAAC;gBAChE,IAAI,KAAK,EAAE,CAAC;oBACV,IAAI,CAAC,aAAa,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;gBACjD,CAAC;YACH,CAAC;QACH,CAAC;QAED,IAAI,MAAM,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;YAC1D,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC;QAChC,CAAC;IACH,CAAC;IAED,OAAO,IAAI,CAAC;AACd,CAAC"}
\ No newline at end of file
diff --git a/docs/testing/laminar.md b/docs/testing/laminar.md
index 146d321..ba3e68b 100644
--- a/docs/testing/laminar.md
+++ b/docs/testing/laminar.md
@@ -227,6 +227,95 @@ logq --around corr=abc123 --window 10 reports/kernel.spec/connect_moves_data_1_1
 logq evt=test.error reports/**/*.jsonl
 ```
 
+## CLI: lam
+
+The `lam` CLI provides comprehensive test management and analysis capabilities.
+
+### Commands
+
+#### Test Execution
+- `lam run [--lane ci|pty|auto] [--filter <pattern>]` — run tests
+- `lam summary` — list all test results from latest run
+
+#### Failure Analysis
+- `lam show --case <suite/case> [--around <pattern>] [--window <n>]` — inspect test artifacts
+- `lam digest [--cases <case1,case2,...>]` — generate failure digests
+- `lam trends [--since <timestamp>] [--until <timestamp>] [--top <n>]` — analyze failure history
+
+#### Configuration
+- `lam rules get` — show current digest rules
+- `lam rules set --file <path> | --inline '<json>'` — update digest rules
+
+#### Integration
+- `lam ingest --go [--from-file <path> | --cmd "<command>"]` — ingest Go test results
+
+### lam trends — Failure Trend Analysis
+
+Analyzes `reports/history.jsonl` to identify recurring failures and track failure patterns over time.
+
+**Usage:**
+```bash
+lam trends [--since <timestamp>] [--until <timestamp>] [--top <n>]
+```
+
+**Options:**
+- `--since <timestamp>` — filter to failures after this date (ISO 8601 or parseable date string)
+- `--until <timestamp>` — filter to failures before this date (default: now)
+- `--top <n>` — show top N failure fingerprints (default: 10)
+
+**Features:**
+- **Fingerprint grouping**: Groups failures by fingerprint to identify recurring issues
+- **Temporal tracking**: Shows first seen and last seen timestamps for each failure pattern
+- **Failure statistics**: Displays total runs, failure count, and failure rate
+- **Top offenders**: Ranks failures by occurrence count
+- **Location tracking**: Shows all file locations where each failure occurred
+
+**Example Output:**
+```
+=== Laminar Trends ===
+Period: 1970-01-01T00:00:00.000Z → 2025-10-12T18:30:45.123Z
+Total test runs: 342
+Total failures: 28
+Failure rate: 8.2%
+Unique failure fingerprints: 5
+
+=== Top 10 Offenders ===
+
+#1 kernel.spec/connect_moves_data_1_1 (12 failures)
+   Fingerprint: fp-abc123def456
+   First seen:  2025-10-01T14:23:11.000Z
+   Last seen:   2025-10-12T17:45:22.000Z
+   Locations:   /srv/repos0/mkolbol/tests/kernel.spec.ts:45
+   Error:       Expected value to be 42, got 40
+
+#2 topology.spec/rewire_edges (8 failures)
+   Fingerprint: fp-xyz789abc012
+   First seen:  2025-10-05T09:12:33.000Z
+   Last seen:   2025-10-12T16:20:15.000Z
+   Locations:   /srv/repos0/mkolbol/tests/topology.spec.ts:128
+   Error:       Assertion failed: edge count mismatch
+```
+
+**Examples:**
+```bash
+# Show all-time trends
+lam trends
+
+# Show top 20 failures
+lam trends --top 20
+
+# Show failures from the last week
+lam trends --since 2025-10-05
+
+# Show failures in a specific date range
+lam trends --since 2025-10-01 --until 2025-10-10
+```
+
+**Requirements:**
+- `reports/history.jsonl` must exist (generated by test runs with fingerprinting enabled)
+- History entries must contain: `ts`, `fingerprint`, `caseName`, `status`
+- Optional fields: `location`, `errorMessage`
+
 ## CLI: logq
 A tiny CLI to slice/filter JSONL by fields and windows.
 
diff --git a/scripts/lam.ts b/scripts/lam.ts
index 3b96327..ac3968a 100644
--- a/scripts/lam.ts
+++ b/scripts/lam.ts
@@ -19,6 +19,7 @@ Usage:
   lam ingest --go [--from-file <path> | --cmd "<command>"]
   lam rules get
   lam rules set --file <path> | --inline '<json>'
+  lam trends [--since <timestamp>] [--until <timestamp>] [--top <n>]
 
 Examples:
   lam run --lane auto
@@ -30,6 +31,7 @@ Examples:
   lam ingest --go --cmd "go test -json ./..."
   lam rules get
   lam rules set --inline '{"budget":{"kb":2}}'
+  lam trends --top 10 --since 2025-10-01
 `);
 }
 
@@ -278,6 +280,116 @@ async function main() {
       }
       break;
     }
+    case 'trends': {
+      const historyPath = 'reports/history.jsonl';
+      if (!fs.existsSync(historyPath)) {
+        console.error('No history.jsonl found. Run tests first to generate failure history.');
+        process.exit(1);
+      }
+      
+      const sinceArg = args.get('since') as string | undefined;
+      const untilArg = args.get('until') as string | undefined;
+      const topN = parseInt((args.get('top') as string) || '10', 10);
+      
+      const sinceTs = sinceArg ? new Date(sinceArg).getTime() : 0;
+      const untilTs = untilArg ? new Date(untilArg).getTime() : Date.now();
+      
+      interface HistoryEntry {
+        ts: number;
+        fingerprint: string;
+        caseName: string;
+        status: 'fail' | 'pass' | 'skip';
+        location?: string;
+        errorMessage?: string;
+      }
+      
+      const entries: HistoryEntry[] = fs.readFileSync(historyPath, 'utf-8')
+        .trim()
+        .split(/\n+/)
+        .map(line => {
+          try {
+            return JSON.parse(line);
+          } catch {
+            return undefined;
+          }
+        })
+        .filter(Boolean);
+      
+      const filtered = entries.filter(e => e.ts >= sinceTs && e.ts <= untilTs);
+      
+      interface FailureStats {
+        fingerprint: string;
+        caseName: string;
+        count: number;
+        firstSeen: number;
+        lastSeen: number;
+        locations: Set<string>;
+        errorSamples: string[];
+      }
+      
+      const failureMap = new Map<string, FailureStats>();
+      
+      for (const entry of filtered) {
+        if (entry.status !== 'fail') continue;
+        
+        const fp = entry.fingerprint;
+        if (!failureMap.has(fp)) {
+          failureMap.set(fp, {
+            fingerprint: fp,
+            caseName: entry.caseName,
+            count: 0,
+            firstSeen: entry.ts,
+            lastSeen: entry.ts,
+            locations: new Set(),
+            errorSamples: [],
+          });
+        }
+        
+        const stats = failureMap.get(fp)!;
+        stats.count++;
+        stats.lastSeen = Math.max(stats.lastSeen, entry.ts);
+        stats.firstSeen = Math.min(stats.firstSeen, entry.ts);
+        if (entry.location) stats.locations.add(entry.location);
+        if (entry.errorMessage && stats.errorSamples.length < 3) {
+          stats.errorSamples.push(entry.errorMessage);
+        }
+      }
+      
+      const sorted = Array.from(failureMap.values()).sort((a, b) => b.count - a.count);
+      const topFailures = sorted.slice(0, topN);
+      
+      const totalFailures = filtered.filter(e => e.status === 'fail').length;
+      const totalTests = filtered.length;
+      const failureRate = totalTests > 0 ? ((totalFailures / totalTests) * 100).toFixed(1) : '0.0';
+      
+      console.log(`\n=== Laminar Trends ===`);
+      console.log(`Period: ${new Date(sinceTs).toISOString()} → ${new Date(untilTs).toISOString()}`);
+      console.log(`Total test runs: ${totalTests}`);
+      console.log(`Total failures: ${totalFailures}`);
+      console.log(`Failure rate: ${failureRate}%`);
+      console.log(`Unique failure fingerprints: ${failureMap.size}`);
+      console.log(`\n=== Top ${topN} Offenders ===\n`);
+      
+      for (let i = 0; i < topFailures.length; i++) {
+        const f = topFailures[i];
+        const firstSeenDate = new Date(f.firstSeen).toISOString();
+        const lastSeenDate = new Date(f.lastSeen).toISOString();
+        const locationList = Array.from(f.locations).join(', ');
+        
+        console.log(`#${i + 1} ${f.caseName} (${f.count} failures)`);
+        console.log(`   Fingerprint: ${f.fingerprint}`);
+        console.log(`   First seen:  ${firstSeenDate}`);
+        console.log(`   Last seen:   ${lastSeenDate}`);
+        if (locationList) {
+          console.log(`   Locations:   ${locationList}`);
+        }
+        if (f.errorSamples.length > 0) {
+          console.log(`   Error:       ${f.errorSamples[0].substring(0, 100)}${f.errorSamples[0].length > 100 ? '...' : ''}`);
+        }
+        console.log('');
+      }
+      break;
+    }
     default:
       printHelp();
   }
diff --git a/scripts/laminar-run.ts b/scripts/laminar-run.ts
index 55cf24a..98740d3 100644
--- a/scripts/laminar-run.ts
+++ b/scripts/laminar-run.ts
@@ -1,6 +1,7 @@
 import { spawnSync } from 'node:child_process';
 import * as fs from 'node:fs';
 import { generateAllDigests } from '../src/digest/generator.js';
+import { generateFingerprint, extractFailureInfo, type HistoryEntry } from '../src/digest/fingerprint.js';
 
 type SummaryEntry = {
   status: 'pass'|'fail'|'skip';
@@ -8,6 +9,7 @@ type SummaryEntry = {
   location: string; // file:line
   artifactURI?: string;
   error?: string;
+  testName?: string;
 };
 
 type StabilityResult = {
@@ -51,6 +53,50 @@ function caseFromArtifact(uri?: string): string {
   return m ? m[1] : 'debug.case';
 }
 
+function updateHistory(entries: SummaryEntry[], runMetadata?: Record<string, any>) {
+  fs.mkdirSync('reports', { recursive: true });
+  const historyPath = 'reports/history.jsonl';
+  const timestamp = new Date().toISOString();
+  
+  for (const entry of entries) {
+    const testName = entry.testName || caseFromArtifact(entry.artifactURI);
+    let fingerprint = '';
+    
+    if (entry.status === 'fail') {
+      let payload: any = undefined;
+      
+      if (entry.artifactURI && fs.existsSync(entry.artifactURI)) {
+        try {
+          const content = fs.readFileSync(entry.artifactURI, 'utf-8');
+          const lines = content.trim().split('\n');
+          for (const line of lines) {
+            const evt = JSON.parse(line);
+            if (evt.lvl === 'error' && evt.payload) {
+              payload = evt.payload;
+              break;
+            }
+          }
+        } catch {}
+      }
+      
+      const failureInfo = extractFailureInfo(testName, entry.error, payload);
+      fingerprint = generateFingerprint(failureInfo);
+    }
+    
+    const historyEntry: HistoryEntry = {
+      timestamp,
+      fingerprint,
+      testName,
+      status: entry.status,
+      duration: entry.duration,
+      location: entry.location,
+      runMetadata,
+    };
+    
+    fs.appendFileSync(historyPath, JSON.stringify(historyEntry) + '\n');
+  }
+}
+
 async function runFlakeDetection(reruns: number = 5) {
   console.log(`\n=== FLAKE DETECTION MODE (${reruns} runs per test) ===\n`);
   
@@ -141,6 +187,16 @@ async function runFlakeDetection(reruns: number = 5) {
   }, null, 2));
   console.log(`\nDetailed report saved to ${reportPath}`);
   
+  // Update history ledger for flake detection runs
+  const finalEntries = parseSummary();
+  const runMetadata = {
+    seed,
+    runId: Date.now().toString(),
+    mode: 'flake-detection',
+    reruns,
+  };
+  updateHistory(finalEntries, runMetadata);
+  
   // Exit with error if any flaky tests found
   if (flakyTests.length > 0 || alwaysFail.length > 0) {
     process.exit(1);
@@ -207,6 +263,14 @@ async function main() {
     console.log(`Generated ${digestCount} digest(s) in reports/ directory`);
   }
 
+  // Update history ledger
+  const finalEntries = parseSummary();
+  const runMetadata = {
+    seed: process.env.TEST_SEED || testEnv.TEST_SEED || 'default',
+    runId: Date.now().toString(),
+  };
+  updateHistory(finalEntries, runMetadata);
+
   process.exit(overall);
 }
 
diff --git a/src/digest/fingerprint.ts b/src/digest/fingerprint.ts
new file mode 100644
index 0000000..65bfa94
--- /dev/null
+++ b/src/digest/fingerprint.ts
@@ -0,0 +1,77 @@
+import * as crypto from 'node:crypto';
+
+export interface FailureInfo {
+  testName: string;
+  errorType?: string;
+  stackLocation?: string;
+  errorMessage?: string;
+}
+
+export interface HistoryEntry {
+  timestamp: string;
+  fingerprint: string;
+  testName: string;
+  status: 'pass' | 'fail' | 'skip';
+  duration: number;
+  location: string;
+  runMetadata?: {
+    seed?: string;
+    runId?: string;
+    [key: string]: any;
+  };
+}
+
+export function generateFingerprint(failure: FailureInfo): string {
+  const parts: string[] = [failure.testName];
+  
+  if (failure.errorType) {
+    parts.push(failure.errorType);
+  }
+  
+  if (failure.stackLocation) {
+    parts.push(failure.stackLocation);
+  }
+  
+  const content = parts.join('::');
+  return crypto.createHash('sha256').update(content).digest('hex').substring(0, 16);
+}
+
+export function extractFailureInfo(
+  testName: string,
+  error?: string,
+  payload?: any
+): FailureInfo {
+  const info: FailureInfo = { testName };
+  
+  if (error) {
+    info.errorMessage = error;
+    
+    const errorTypeMatch = error.match(/^(\w+Error)/);
+    if (errorTypeMatch) {
+      info.errorType = errorTypeMatch[1];
+    }
+  }
+  
+  if (payload && typeof payload === 'object') {
+    if ('stack' in payload && typeof payload.stack === 'string') {
+      const stackLines = payload.stack.split('\n');
+      const firstRelevantLine = stackLines.find((line: string) => 
+        line.includes('.spec.ts') || line.includes('.test.ts')
+      );
+      
+      if (firstRelevantLine) {
+        const match = firstRelevantLine.match(/\(([^)]+):(\d+):(\d+)\)/) ||
+                      firstRelevantLine.match(/at ([^:]+):(\d+):(\d+)/);
+        if (match) {
+          info.stackLocation = `${match[1]}:${match[2]}`;
+        }
+      }
+    }
+    
+    if ('name' in payload && typeof payload.name === 'string') {
+      info.errorType = payload.name;
+    }
+  }
+  
+  return info;
+}
diff --git a/tests/laminar/trends.spec.ts b/tests/laminar/trends.spec.ts
new file mode 100644
index 0000000..7d68625
--- /dev/null
+++ b/tests/laminar/trends.spec.ts
@@ -0,0 +1,805 @@
+import { describe, it, expect } from 'vitest';
+import {
+  generateFingerprint,
+  extractFailureInfo,
+  FailureInfo,
+  HistoryEntry,
+} from '../../src/digest/fingerprint';
+
+describe('Failure Fingerprinting and Trends', () => {
+  describe('fingerprint generation', () => {
+    it('generates consistent fingerprint for same failures', () => {
+      const failure: FailureInfo = {
+        testName: 'auth › login fails with invalid password',
+        errorType: 'AssertionError',
+        stackLocation: 'test/auth.spec.ts:42',
+      };
+
+      const fp1 = generateFingerprint(failure);
+      const fp2 = generateFingerprint(failure);
+
+      expect(fp1).toBe(fp2);
+      expect(fp1).toHaveLength(16);
+    });
+
+    it('generates different fingerprints for different test names', () => {
+      const failure1: FailureInfo = {
+        testName: 'test A',
+        errorType: 'Error',
+        stackLocation: 'test.spec.ts:1',
+      };
+
+      const failure2: FailureInfo = {
+        testName: 'test B',
+        errorType: 'Error',
+        stackLocation: 'test.spec.ts:1',
+      };
+
+      expect(generateFingerprint(failure1)).not.toBe(generateFingerprint(failure2));
+    });
+
+    it('generates different fingerprints for different error types', () => {
+      const failure1: FailureInfo = {
+        testName: 'test',
+        errorType: 'TypeError',
+        stackLocation: 'test.spec.ts:1',
+      };
+
+      const failure2: FailureInfo = {
+        testName: 'test',
+        errorType: 'RangeError',
+        stackLocation: 'test.spec.ts:1',
+      };
+
+      expect(generateFingerprint(failure1)).not.toBe(generateFingerprint(failure2));
+    });
+
+    it('generates different fingerprints for different stack locations', () => {
+      const failure1: FailureInfo = {
+        testName: 'test',
+        errorType: 'Error',
+        stackLocation: 'test.spec.ts:10',
+      };
+
+      const failure2: FailureInfo = {
+        testName: 'test',
+        errorType: 'Error',
+        stackLocation: 'test.spec.ts:20',
+      };
+
+      expect(generateFingerprint(failure1)).not.toBe(generateFingerprint(failure2));
+    });
+
+    it('generates fingerprint from test name only when no error details', () => {
+      const failure: FailureInfo = {
+        testName: 'simple test',
+      };
+
+      const fp = generateFingerprint(failure);
+      expect(fp).toHaveLength(16);
+      expect(fp).toMatch(/^[a-f0-9]{16}$/);
+    });
+  });
+
+  describe('failure info extraction', () => {
+    it('extracts error type from error message', () => {
+      const info = extractFailureInfo(
+        'test case',
+        'TypeError: Cannot read property',
+        undefined
+      );
+
+      expect(info.testName).toBe('test case');
+      expect(info.errorType).toBe('TypeError');
+      expect(info.errorMessage).toBe('TypeError: Cannot read property');
+    });
+
+    it('extracts stack location from payload', () => {
+      const payload = {
+        stack: `Error: test failed
+    at test.spec.ts:42:10
+    at runTest (framework.ts:100:5)`,
+      };
+
+      const info = extractFailureInfo('test case', 'Error: test failed', payload);
+
+      expect(info.stackLocation).toBe('test.spec.ts:42');
+    });
+
+    it('extracts error name from payload', () => {
+      const payload = {
+        name: 'AssertionError',
+        stack: 'AssertionError\n    at test.spec.ts:10:5',
+      };
+
+      const info = extractFailureInfo('test', 'assertion failed', payload);
+
+      expect(info.errorType).toBe('AssertionError');
+    });
+
+    it('handles payload with parenthesis-style stack format', () => {
+      const payload = {
+        stack: `Error: failed
+    at Context.test (test.spec.ts:30:15)
+    at run (mocha.js:200:10)`,
+      };
+
+      const info = extractFailureInfo('test', 'Error: failed', payload);
+
+      expect(info.stackLocation).toBe('test.spec.ts:30');
+    });
+
+    it('handles missing error details gracefully', () => {
+      const info = extractFailureInfo('test name', undefined, undefined);
+
+      expect(info.testName).toBe('test name');
+      expect(info.errorMessage).toBeUndefined();
+      expect(info.errorType).toBeUndefined();
+      expect(info.stackLocation).toBeUndefined();
+    });
+  });
+
+  describe('history ledger creation', () => {
+    it('creates valid history entry from test result', () => {
+      const entry: HistoryEntry = {
+        timestamp: new Date('2024-10-12T10:00:00Z').toISOString(),
+        fingerprint: 'abc123def456',
+        testName: 'login test',
+        status: 'fail',
+        duration: 1250,
+        location: 'auth.spec.ts:42',
+        runMetadata: {
+          runId: 'run-001',
+          seed: 'seed-123',
+        },
+      };
+
+      expect(entry.timestamp).toBe('2024-10-12T10:00:00.000Z');
+      expect(entry.fingerprint).toBe('abc123def456');
+      expect(entry.status).toBe('fail');
+      expect(entry.duration).toBe(1250);
+    });
+
+    it('appends entries to history', () => {
+      const history: HistoryEntry[] = [];
+
+      const failure: FailureInfo = {
+        testName: 'flaky test',
+        errorType: 'TimeoutError',
+        stackLocation: 'test.spec.ts:100',
+      };
+
+      const fingerprint = generateFingerprint(failure);
+
+      for (let i = 0; i < 5; i++) {
+        history.push({
+          timestamp: new Date(Date.UTC(2024, 9, 12, 10, i, 0)).toISOString(),
+          fingerprint,
+          testName: failure.testName,
+          status: i % 2 === 0 ? 'fail' : 'pass',
+          duration: 1000 + i * 100,
+          location: 'test.spec.ts:100',
+          runMetadata: { runId: `run-${i}` },
+        });
+      }
+
+      expect(history).toHaveLength(5);
+      expect(history.every(e => e.fingerprint === fingerprint)).toBe(true);
+      expect(history.filter(e => e.status === 'fail')).toHaveLength(3);
+      expect(history.filter(e => e.status === 'pass')).toHaveLength(2);
+    });
+  });
+
+  describe('trend analysis with synthetic multi-run history', () => {
+    it('calculates failure rate from history', () => {
+      const failure: FailureInfo = {
+        testName: 'database connection test',
+        errorType: 'ConnectionError',
+        stackLocation: 'db.spec.ts:25',
+      };
+
+      const fingerprint = generateFingerprint(failure);
+      const history: HistoryEntry[] = [];
+
+      for (let i = 0; i < 10; i++) {
+        history.push({
+          timestamp: new Date(Date.UTC(2024, 9, 12, 10, i, 0)).toISOString(),
+          fingerprint,
+          testName: failure.testName,
+          status: i < 7 ? 'fail' : 'pass',
+          duration: 2000,
+          location: 'db.spec.ts:25',
+        });
+      }
+
+      const failureCount = history.filter(e => e.status === 'fail').length;
+      const failureRate = failureCount / history.length;
+
+      expect(failureRate).toBe(0.7);
+      expect(failureCount).toBe(7);
+    });
+
+    it('identifies first and last seen timestamps', () => {
+      const fingerprint = generateFingerprint({
+        testName: 'test',
+        errorType: 'Error',
+      });
+
+      const history: HistoryEntry[] = [
+        {
+          timestamp: '2024-10-01T10:00:00.000Z',
+          fingerprint,
+          testName: 'test',
+          status: 'fail',
+          duration: 100,
+          location: 'test.spec.ts:1',
+        },
+        {
+          timestamp: '2024-10-05T10:00:00.000Z',
+          fingerprint,
+          testName: 'test',
+          status: 'fail',
+          duration: 100,
+          location: 'test.spec.ts:1',
+        },
+        {
+          timestamp: '2024-10-10T10:00:00.000Z',
+          fingerprint,
+          testName: 'test',
+          status: 'fail',
+          duration: 100,
+          location: 'test.spec.ts:1',
+        },
+      ];
+
+      const firstSeen = new Date(history[0].timestamp);
+      const lastSeen = new Date(history[history.length - 1].timestamp);
+
+      expect(firstSeen.toISOString()).toBe('2024-10-01T10:00:00.000Z');
+      expect(lastSeen.toISOString()).toBe('2024-10-10T10:00:00.000Z');
+    });
+
+    it('tracks trend over time windows', () => {
+      const fingerprint = generateFingerprint({
+        testName: 'api test',
+        errorType: 'NetworkError',
+      });
+
+      const history: HistoryEntry[] = [];
+      const baseDate = new Date('2024-10-01T00:00:00.000Z');
+
+      for (let day = 0; day < 14; day++) {
+        for (let run = 0; run < 3; run++) {
+          const timestamp = new Date(baseDate);
+          timestamp.setDate(baseDate.getDate() + day);
+          timestamp.setHours(run * 8);
+
+          history.push({
+            timestamp: timestamp.toISOString(),
+            fingerprint,
+            testName: 'api test',
+            status: day < 7 ? 'fail' : (run === 0 ? 'fail' : 'pass'),
+            duration: 500,
+            location: 'api.spec.ts:50',
+          });
+        }
+      }
+
+      const week1 = history.slice(0, 21);
+      const week2 = history.slice(21);
+
+      const week1FailRate = week1.filter(e => e.status === 'fail').length / week1.length;
+      const week2FailRate = week2.filter(e => e.status === 'fail').length / week2.length;
+
+      expect(week1FailRate).toBeGreaterThan(week2FailRate);
+      expect(week1FailRate).toBeCloseTo(1.0, 1);
+      expect(week2FailRate).toBeCloseTo(0.33, 1);
+    });
+  });
+
+  describe('top offender ranking', () => {
+    it('ranks failures by frequency', () => {
+      const failures = [
+        { testName: 'test A', errorType: 'Error', stackLocation: 'a.spec.ts:1' },
+        { testName: 'test B', errorType: 'Error', stackLocation: 'b.spec.ts:1' },
+        { testName: 'test C', errorType: 'Error', stackLocation: 'c.spec.ts:1' },
+      ];
+
+      const history: HistoryEntry[] = [];
+
+      for (let i = 0; i < 10; i++) {
+        const failureIndex = i < 6 ? 0 : i < 9 ? 1 : 2;
+        const failure = failures[failureIndex];
+        history.push({
+          timestamp: new Date(Date.UTC(2024, 9, 12, 10, i, 0)).toISOString(),
+          fingerprint: generateFingerprint(failure),
+          testName: failure.testName,
+          status: 'fail',
+          duration: 100,
+          location: failure.stackLocation,
+        });
+      }
+
+      const fingerprintCounts = new Map<string, number>();
+      history.forEach(entry => {
+        fingerprintCounts.set(
+          entry.fingerprint,
+          (fingerprintCounts.get(entry.fingerprint) || 0) + 1
+        );
+      });
+
+      const ranked = Array.from(fingerprintCounts.entries())
+        .sort((a, b) => b[1] - a[1])
+        .map(([fp, count]) => ({ fingerprint: fp, count }));
+
+      expect(ranked[0].count).toBe(6);
+      expect(ranked[1].count).toBe(3);
+      expect(ranked[2].count).toBe(1);
+    });
+
+    it('ranks by failure rate when frequency is similar', () => {
+      const fingerprints = ['fp1', 'fp2', 'fp3'];
+      const history: HistoryEntry[] = [];
+
+      fingerprints.forEach((fp, idx) => {
+        const totalRuns = 10;
+        const failures = idx === 0 ? 9 : idx === 1 ? 7 : 5;
+
+        for (let i = 0; i < totalRuns; i++) {
+          history.push({
+            timestamp: new Date(Date.UTC(2024, 9, 12, idx, i, 0)).toISOString(),
+            fingerprint: fp,
+            testName: `test-${fp}`,
+            status: i < failures ? 'fail' : 'pass',
+            duration: 100,
+            location: 'test.spec.ts:1',
+          });
+        }
+      });
+
+      const stats = new Map<string, { total: number; failures: number }>();
+      history.forEach(entry => {
+        const current = stats.get(entry.fingerprint) || { total: 0, failures: 0 };
+        current.total++;
+        if (entry.status === 'fail') current.failures++;
+        stats.set(entry.fingerprint, current);
+      });
+
+      const ranked = Array.from(stats.entries())
+        .map(([fp, s]) => ({ fingerprint: fp, rate: s.failures / s.total }))
+        .sort((a, b) => b.rate - a.rate);
+
+      expect(ranked[0].fingerprint).toBe('fp1');
+      expect(ranked[0].rate).toBe(0.9);
+      expect(ranked[1].fingerprint).toBe('fp2');
+      expect(ranked[1].rate).toBe(0.7);
+      expect(ranked[2].fingerprint).toBe('fp3');
+      expect(ranked[2].rate).toBe(0.5);
+    });
+
+    it('combines frequency and rate for top offender score', () => {
+      interface OffenderStats {
+        fingerprint: string;
+        testName: string;
+        failures: number;
+        total: number;
+        rate: number;
+        score: number;
+      }
+
+      const testData = [
+        { name: 'high freq high rate', failures: 10, passes: 0 },
+        { name: 'low freq high rate', failures: 2, passes: 0 },
+        { name: 'high freq low rate', failures: 5, passes: 10 },
+      ];
+
+      const offenders: OffenderStats[] = testData.map(t => {
+        const total = t.failures + t.passes;
+        const rate = t.failures / total;
+        const score = t.failures * rate;
+
+        return {
+          fingerprint: generateFingerprint({ testName: t.name }),
+          testName: t.name,
+          failures: t.failures,
+          total,
+          rate,
+          score,
+        };
+      });
+
+      offenders.sort((a, b) => b.score - a.score);
+
+      expect(offenders[0].testName).toBe('high freq high rate');
+      expect(offenders[0].score).toBe(10);
+      expect(offenders[1].testName).toBe('low freq high rate');
+      expect(offenders[1].score).toBe(2);
+    });
+  });
+
+  describe('time range filtering', () => {
+    it('filters history by date range', () => {
+      const fingerprint = generateFingerprint({ testName: 'test' });
+      const allHistory: HistoryEntry[] = [];
+
+      for (let day = 0; day < 30; day++) {
+        allHistory.push({
+          timestamp: new Date(Date.UTC(2024, 9, day + 1, 10, 0, 0)).toISOString(),
+          fingerprint,
+          testName: 'test',
+          status: 'fail',
+          duration: 100,
+          location: 'test.spec.ts:1',
+        });
+      }
+
+      const startDate = new Date('2024-10-10T00:00:00.000Z');
+      const endDate = new Date('2024-10-20T23:59:59.999Z');
+
+      const filtered = allHistory.filter(entry => {
+        const entryDate = new Date(entry.timestamp);
+        return entryDate >= startDate && entryDate <= endDate;
+      });
+
+      expect(filtered.length).toBe(11);
+      expect(new Date(filtered[0].timestamp).getUTCDate()).toBe(10);
+      expect(new Date(filtered[filtered.length - 1].timestamp).getUTCDate()).toBe(20);
+    });
+
+    it('filters last N runs', () => {
+      const history: HistoryEntry[] = [];
+
+      for (let i = 0; i < 100; i++) {
+        history.push({
+          timestamp: new Date(Date.UTC(2024, 9, 12, 10, i, 0)).toISOString(),
+          fingerprint: 'fp',
+          testName: 'test',
+          status: 'fail',
+          duration: 100,
+          location: 'test.spec.ts:1',
+          runMetadata: { runId: `run-${i}` },
+        });
+      }
+
+      const lastN = 10;
+      const recent = history.slice(-lastN);
+
+      expect(recent.length).toBe(10);
+      expect(recent[0].runMetadata?.runId).toBe('run-90');
+      expect(recent[recent.length - 1].runMetadata?.runId).toBe('run-99');
+    });
+
+    it('filters by rolling time window', () => {
+      const fingerprint = generateFingerprint({ testName: 'test' });
+      const now = new Date('2024-10-12T15:00:00.000Z');
+      const history: HistoryEntry[] = [];
+
+      for (let hours = 48; hours >= 0; hours--) {
+        const timestamp = new Date(now);
+        timestamp.setHours(now.getHours() - hours);
+
+        history.push({
+          timestamp: timestamp.toISOString(),
+          fingerprint,
+          testName: 'test',
+          status: hours % 3 === 0 ? 'fail' : 'pass',
+          duration: 100,
+          location: 'test.spec.ts:1',
+        });
+      }
+
+      const windowHours = 24;
+      const cutoff = new Date(now);
+      cutoff.setHours(cutoff.getHours() - windowHours);
+
+      const inWindow = history.filter(e => new Date(e.timestamp) >= cutoff);
+
+      expect(inWindow.length).toBeLessThan(history.length);
+      expect(inWindow.length).toBe(25);
+    });
+  });
+
+  describe('Node.js test data integration', () => {
+    it('generates fingerprints for Node.js test failures', () => {
+      const nodeFailures = [
+        {
+          testName: 'API › GET /users › returns user list',
+          error: 'AssertionError: expected 200 to equal 404',
+          stack: `AssertionError: expected 200 to equal 404
+    at Context.<anonymous> (test/api.spec.ts:45:30)
+    at processImmediate (node:internal/timers:478:21)`,
+        },
+        {
+          testName: 'Database › connection › establishes connection',
+          error: 'Error: Connection timeout',
+          stack: `Error: Connection timeout
+    at Timeout._onTimeout (test/db.spec.ts:20:15)
+    at listOnTimeout (node:internal/timers:569:17)`,
+        },
+      ];
+
+      const fingerprints = nodeFailures.map(f => {
+        const info = extractFailureInfo(f.testName, f.error, { stack: f.stack });
+        return generateFingerprint(info);
+      });
+
+      expect(fingerprints[0]).toHaveLength(16);
+      expect(fingerprints[1]).toHaveLength(16);
+      expect(fingerprints[0]).not.toBe(fingerprints[1]);
+    });
+
+    it('creates history from Node.js test runs', () => {
+      const testRuns = [
+        { name: 'async test', status: 'pass' as const, time: 150 },
+        { name: 'async test', status: 'fail' as const, time: 200 },
+        { name: 'async test', status: 'fail' as const, time: 180 },
+      ];
+
+      const history: HistoryEntry[] = testRuns.map((run, idx) => ({
+        timestamp: new Date(Date.UTC(2024, 9, 12, 10, idx, 0)).toISOString(),
+        fingerprint: generateFingerprint({ testName: run.name }),
+        testName: run.name,
+        status: run.status,
+        duration: run.time,
+        location: 'async.spec.ts:10',
+      }));
+
+      expect(history).toHaveLength(3);
+      expect(history.filter(e => e.status === 'fail')).toHaveLength(2);
+      const failRate = history.filter(e => e.status === 'fail').length / history.length;
+      expect(failRate).toBeCloseTo(0.667, 2);
+    });
+  });
+
+  describe('Go test data integration', () => {
+    it('generates fingerprints for Go test failures', () => {
+      const goFailures = [
+        {
+          testName: 'TestDivide',
+          package: 'github.com/example/calc',
+          error: 'calc_test.go:31: Error: division by zero',
+        },
+        {
+          testName: 'TestValidation',
+          package: 'github.com/example/utils',
+          error: 'utils_test.go:15: validation failed',
+        },
+      ];
+
+      const fingerprints = goFailures.map(f => {
+        const info: FailureInfo = {
+          testName: f.testName,
+          errorMessage: f.error,
+          stackLocation: f.error.match(/([^:]+\.go:\d+)/)?.[1],
+        };
+        return generateFingerprint(info);
+      });
+
+      expect(fingerprints[0]).toHaveLength(16);
+      expect(fingerprints[1]).toHaveLength(16);
+      expect(fingerprints[0]).not.toBe(fingerprints[1]);
+    });
+
+    it('creates history from Go test runs', () => {
+      const goTestOutput = [
+        {
+          testName: 'TestAdd',
+          package: 'github.com/example/calc',
+          action: 'pass' as const,
+          elapsed: 0.09,
+        },
+        {
+          testName: 'TestDivide',
+          package: 'github.com/example/calc',
+          action: 'fail' as const,
+          elapsed: 0.09,
+        },
+      ];
+
+      const history: HistoryEntry[] = goTestOutput.map((test, idx) => ({
+        timestamp: new Date(Date.UTC(2024, 9, 12, 10, 0, idx)).toISOString(),
+        fingerprint: generateFingerprint({ testName: test.testName }),
+        testName: test.testName,
+        status: test.action === 'pass' ? 'pass' : 'fail',
+        duration: test.elapsed * 1000,
+        location: `${test.package}/${test.testName}`,
+      }));
+
+      expect(history).toHaveLength(2);
+      expect(history[0].status).toBe('pass');
+      expect(history[1].status).toBe('fail');
+    });
+
+    it('handles Go panic failures', () => {
+      const panicFailure = {
+        testName: 'TestPanic',
+        error: `panic: runtime error: invalid memory address
+calc_test.go:50 +0x123
+testing.tRunner(0xc000010e00, 0x10f1a0)
+testing.go:1259 +0x102`,
+      };
+
+      const info = extractFailureInfo(
+        panicFailure.testName,
+        panicFailure.error,
+        { stack: panicFailure.error }
+      );
+
+      const fingerprint = generateFingerprint(info);
+
+      expect(fingerprint).toHaveLength(16);
+      expect(info.testName).toBe('TestPanic');
+    });
+  });
+
+  describe('regression detection', () => {
+    it('detects new regression from passing to failing', () => {
+      const fingerprint = generateFingerprint({
+        testName: 'regression test',
+        errorType: 'Error',
+      });
+
+      const history: HistoryEntry[] = [];
+
+      for (let i = 0; i < 10; i++) {
+        history.push({
+          timestamp: new Date(Date.UTC(2024, 9, 12, 10, i, 0)).toISOString(),
+          fingerprint,
+          testName: 'regression test',
+          status: i < 8 ? 'pass' : 'fail',
+          duration: 100,
+          location: 'test.spec.ts:1',
+        });
+      }
+
+      let isRegression = false;
+      for (let i = 1; i < history.length; i++) {
+        if (history[i - 1].status === 'pass' && history[i].status === 'fail') {
+          isRegression = true;
+          break;
+        }
+      }
+
+      expect(isRegression).toBe(true);
+    });
+
+    it('identifies flaky tests with intermittent failures', () => {
+      const fingerprint = generateFingerprint({ testName: 'flaky' });
+      const history: HistoryEntry[] = [];
+
+      const pattern = ['pass', 'fail', 'pass', 'pass', 'fail', 'pass', 'fail', 'pass'];
+      pattern.forEach((status, i) => {
+        history.push({
+          timestamp: new Date(Date.UTC(2024, 9, 12, 10, i, 0)).toISOString(),
+          fingerprint,
+          testName: 'flaky',
+          status: status as 'pass' | 'fail',
+          duration: 100,
+          location: 'test.spec.ts:1',
+        });
+      });
+
+      let transitionCount = 0;
+      for (let i = 1; i < history.length; i++) {
+        if (history[i].status !== history[i - 1].status) {
+          transitionCount++;
+        }
+      }
+
+      const transitionRate = transitionCount / (history.length - 1);
+      const isFlaky = transitionCount >= 3 || transitionRate > 0.4;
+      expect(isFlaky).toBe(true);
+      expect(transitionCount).toBeGreaterThanOrEqual(5);
+    });
+
+    it('tracks recovery from failures', () => {
+      const fingerprint = generateFingerprint({ testName: 'recovery test' });
+      const history: HistoryEntry[] = [];
+
+      const statuses: Array<'fail' | 'pass'> = [
+        'fail', 'fail', 'fail', 'fail', 'fail',
+        'pass', 'pass', 'pass', 'pass', 'pass',
+      ];
+
+      statuses.forEach((status, i) => {
+        history.push({
+          timestamp: new Date(Date.UTC(2024, 9, 12, 10, i, 0)).toISOString(),
+          fingerprint,
+          testName: 'recovery test',
+          status,
+          duration: 100,
+          location: 'test.spec.ts:1',
+        });
+      });
+
+      const recentWindow = 5;
+      const recent = history.slice(-recentWindow);
+      const recentFailures = recent.filter(e => e.status === 'fail').length;
+
+      const hasRecovered = recentFailures === 0;
+      expect(hasRecovered).toBe(true);
+    });
+  });
+
+  describe('comprehensive trend analysis', () => {
+    it('analyzes complex multi-test multi-run scenario', () => {
+      interface TrendData {
+        fingerprint: string;
+        testName: string;
+        firstSeen: string;
+        lastSeen: string;
+        totalRuns: number;
+        failures: number;
+        failureRate: number;
+        avgDuration: number;
+      }
+
+      const tests = [
+        { name: 'critical path test', baseFailRate: 0.1, baseDuration: 500 },
+        { name: 'flaky network test', baseFailRate: 0.4, baseDuration: 2000 },
+        { name: 'stable unit test', baseFailRate: 0.01, baseDuration: 50 },
+      ];
+
+      const allHistory: HistoryEntry[] = [];
+
+      tests.forEach(test => {
+        const fingerprint = generateFingerprint({
+          testName: test.name,
+          errorType: 'Error',
+        });
+
+        for (let run = 0; run < 50; run++) {
+          const shouldFail = Math.random() < test.baseFailRate;
+          allHistory.push({
+            timestamp: new Date(Date.UTC(2024, 9, 12, 10, run, 0)).toISOString(),
+            fingerprint,
+            testName: test.name,
+            status: shouldFail ? 'fail' : 'pass',
+            duration: test.baseDuration + (Math.random() - 0.5) * 100,
+            location: 'test.spec.ts:1',
+            runMetadata: { runId: `run-${run}` },
+          });
+        }
+      });
+
+      const trendsByFingerprint = new Map<string, TrendData>();
+
+      allHistory.forEach(entry => {
+        const existing = trendsByFingerprint.get(entry.fingerprint);
+        if (!existing) {
+          trendsByFingerprint.set(entry.fingerprint, {
+            fingerprint: entry.fingerprint,
+            testName: entry.testName,
+            firstSeen: entry.timestamp,
+            lastSeen: entry.timestamp,
+            totalRuns: 1,
+            failures: entry.status === 'fail' ? 1 : 0,
+            failureRate: 0,
+            avgDuration: entry.duration,
+          });
+        } else {
+          existing.lastSeen = entry.timestamp;
+          existing.totalRuns++;
+          if (entry.status === 'fail') existing.failures++;
+          existing.avgDuration = 
+            (existing.avgDuration * (existing.totalRuns - 1) + entry.duration) /
+            existing.totalRuns;
+        }
+      });
+
+      trendsByFingerprint.forEach(trend => {
+        trend.failureRate = trend.failures / trend.totalRuns;
+      });
+
+      const trends = Array.from(trendsByFingerprint.values());
+      expect(trends).toHaveLength(3);
+
+      const topOffenders = trends
+        .sort((a, b) => b.failureRate - a.failureRate)
+        .slice(0, 2);
+
+      expect(topOffenders[0].testName).toBe('flaky network test');
+      expect(topOffenders[0].failureRate).toBeGreaterThan(0.2);
+    });
+  });
+});
