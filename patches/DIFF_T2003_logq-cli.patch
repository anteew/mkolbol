diff --git a/package.json b/package.json
index 161c237..1410217 100644
--- a/package.json
+++ b/package.json
@@ -27,7 +27,7 @@
   "scripts": {
     "docs": "echo 'See docs/rfcs/stream-kernel/00-index.md for architecture documentation'",
     "build": "tsc -p tsconfig.json",
-    "test": "vitest run --reporter=default",
+    "test": "vitest run",
     "test:watch": "vitest",
     "dev": "node --enable-source-maps dist/examples/basic-topology.js",
     "dev:split": "node --enable-source-maps dist/examples/split-topology.js",
diff --git a/scripts/logq.ts b/scripts/logq.ts
new file mode 100644
index 0000000..637d3c5
--- /dev/null
+++ b/scripts/logq.ts
@@ -0,0 +1,193 @@
+#!/usr/bin/env node
+import { readFileSync } from 'fs';
+import { join } from 'path';
+
+interface LogEntry {
+  ts?: number;
+  lvl?: string;
+  case?: string;
+  phase?: string;
+  evt?: string;
+  id?: string;
+  corr?: string;
+  path?: string;
+  payload?: unknown;
+  [key: string]: unknown;
+}
+
+interface FilterSpec {
+  field: string;
+  pattern: RegExp | string;
+}
+
+interface Options {
+  filters: FilterSpec[];
+  around?: string;
+  window?: number;
+  raw: boolean;
+  help: boolean;
+  filePath: string;
+}
+
+function parseArgs(args: string[]): Options {
+  const options: Options = {
+    filters: [],
+    raw: false,
+    help: false,
+    filePath: '',
+  };
+
+  for (let i = 0; i < args.length; i++) {
+    const arg = args[i];
+
+    if (arg === '--help' || arg === '-h') {
+      options.help = true;
+    } else if (arg === '--raw') {
+      options.raw = true;
+    } else if (arg === '--around') {
+      options.around = args[++i];
+    } else if (arg === '--window') {
+      options.window = parseInt(args[++i], 10);
+    } else if (arg.includes('=')) {
+      const [field, value] = arg.split('=', 2);
+      const pattern = value.startsWith('/') && value.endsWith('/')
+        ? new RegExp(value.slice(1, -1))
+        : value;
+      options.filters.push({ field, pattern });
+    } else if (!arg.startsWith('-')) {
+      if (options.filePath) {
+        options.filters.push({ field: 'evt', pattern: arg });
+      } else {
+        options.filePath = arg;
+      }
+    }
+  }
+
+  return options;
+}
+
+function matchesFilter(entry: LogEntry, filter: FilterSpec): boolean {
+  const value = entry[filter.field];
+  if (value === undefined) return false;
+
+  const strValue = String(value);
+  if (filter.pattern instanceof RegExp) {
+    return filter.pattern.test(strValue);
+  }
+  return strValue === filter.pattern;
+}
+
+function matchesAllFilters(entry: LogEntry, filters: FilterSpec[]): boolean {
+  if (filters.length === 0) return true;
+  return filters.every(filter => matchesFilter(entry, filter));
+}
+
+function formatCompact(entry: LogEntry): string {
+  const ts = entry.ts ? new Date(entry.ts).toISOString() : '???';
+  const lvl = entry.lvl || '?';
+  const caseName = entry.case || '?';
+  const evt = entry.evt || '?';
+  const phase = entry.phase ? `[${entry.phase}]` : '';
+  const corr = entry.corr ? `corr=${entry.corr}` : '';
+  const path = entry.path ? `@${entry.path}` : '';
+  const extra = [phase, corr, path].filter(Boolean).join(' ');
+  
+  return `${ts} ${lvl.padEnd(5)} ${caseName} ${evt} ${extra}`.trim();
+}
+
+function processJsonlFile(filePath: string, options: Options): void {
+  const content = readFileSync(filePath, 'utf-8');
+  const lines = content.trim().split('\n').filter(Boolean);
+  const entries: LogEntry[] = lines.map(line => JSON.parse(line));
+
+  let filtered = entries.filter(entry => matchesAllFilters(entry, options.filters));
+
+  if (options.around) {
+    const [field, value] = options.around.split('=', 2);
+    const centerIdx = filtered.findIndex(entry => String(entry[field]) === value);
+    
+    if (centerIdx !== -1) {
+      const windowSize = options.window || 5;
+      const start = Math.max(0, centerIdx - windowSize);
+      const end = Math.min(filtered.length, centerIdx + windowSize + 1);
+      filtered = filtered.slice(start, end);
+    } else {
+      filtered = [];
+    }
+  }
+
+  for (const entry of filtered) {
+    if (options.raw) {
+      console.log(JSON.stringify(entry));
+    } else {
+      console.log(formatCompact(entry));
+    }
+  }
+}
+
+function showHelp(): void {
+  console.log(`
+logq - Query JSONL logs with filters and windows
+
+USAGE:
+  node scripts/logq.ts [OPTIONS] [FILTERS...] <file>
+
+FILTERS:
+  field=value      Match exact value (e.g., case=demo.case, evt=case.begin)
+  field=/regex/    Match regex pattern (e.g., evt=/test.*/)
+  value            Shorthand for evt=value (e.g., failures)
+
+OPTIONS:
+  --around field=value   Show lines around a matching entry
+  --window N             Window size for --around (default: 5)
+  --raw                  Output raw JSONL instead of compact format
+  --help, -h             Show this help
+
+EXAMPLES:
+  # Filter by case name
+  node scripts/logq.ts case=demo.case reports/demo/demo.case.jsonl
+
+  # Filter by event type with regex
+  node scripts/logq.ts evt=/case.*/ reports/demo/demo.case.jsonl
+
+  # Show context around a correlation ID
+  node scripts/logq.ts --around corr=abc123 --window 3 reports/demo/demo.case.jsonl
+
+  # Multiple filters
+  node scripts/logq.ts case=demo.case evt=test.step reports/demo/demo.case.jsonl
+
+  # Output raw JSONL
+  node scripts/logq.ts --raw evt=case.begin reports/demo/demo.case.jsonl
+`.trim());
+}
+
+function main(): void {
+  const args = process.argv.slice(2);
+
+  if (args.length === 0) {
+    showHelp();
+    process.exit(0);
+  }
+
+  const options = parseArgs(args);
+
+  if (options.help) {
+    showHelp();
+    process.exit(0);
+  }
+
+  if (!options.filePath) {
+    console.error('Error: No input file specified');
+    showHelp();
+    process.exit(1);
+  }
+
+  try {
+    processJsonlFile(options.filePath, options);
+  } catch (err) {
+    console.error(`Error processing file: ${err instanceof Error ? err.message : String(err)}`);
+    process.exit(1);
+  }
+}
+
+main();
diff --git a/src/test/reporter/jsonlReporter.ts b/src/test/reporter/jsonlReporter.ts
new file mode 100644
index 0000000..cc304e2
--- /dev/null
+++ b/src/test/reporter/jsonlReporter.ts
@@ -0,0 +1,102 @@
+import * as fs from 'fs';
+import * as path from 'path';
+import type { File, Reporter, Task, Vitest } from 'vitest';
+
+interface TestSummary {
+  status: 'pass' | 'fail' | 'skip';
+  duration: number;
+  location: string;
+  artifactURI?: string;
+  error?: string;
+}
+
+export default class JSONLReporter implements Reporter {
+  private ctx!: Vitest;
+  private summaryPath = 'reports/summary.jsonl';
+  private summaryStream?: fs.WriteStream;
+  private processedTests = new Set<string>();
+
+  onInit(ctx: Vitest): void {
+    this.ctx = ctx;
+    const dir = path.dirname(this.summaryPath);
+    fs.mkdirSync(dir, { recursive: true });
+    if (fs.existsSync(this.summaryPath)) {
+      fs.unlinkSync(this.summaryPath);
+    }
+    this.summaryStream = fs.createWriteStream(this.summaryPath, { flags: 'a' });
+  }
+
+  onCollected(): void {
+    const files = this.ctx.state.getFiles();
+    this.processFiles(files);
+  }
+
+  onFinished(files?: File[]): void {
+    if (files) {
+      this.processFiles(files);
+    }
+    if (this.summaryStream) {
+      this.summaryStream.end();
+    }
+  }
+
+  private processFiles(files: File[]): void {
+    for (const file of files) {
+      this.processTask(file);
+    }
+  }
+
+  private processTask(task: Task): void {
+    if (task.type === 'test' && task.result?.state) {
+      const testId = `${task.file?.filepath}:${task.name}`;
+      if (!this.processedTests.has(testId)) {
+        this.processedTests.add(testId);
+        this.reportTest(task);
+      }
+    }
+
+    if ('tasks' in task && Array.isArray(task.tasks)) {
+      for (const child of task.tasks) {
+        this.processTask(child);
+      }
+    }
+  }
+
+  private reportTest(task: Task): void {
+    const result = task.result!;
+    const state = result.state;
+    
+    if (state !== 'pass' && state !== 'fail' && state !== 'skip') {
+      return;
+    }
+
+    const duration = result.duration || 0;
+    const file = task.file;
+    const location = file ? `${file.filepath}:${task.location?.line || 0}` : 'unknown';
+    
+    const status = state === 'pass' ? '✓' : state === 'fail' ? '✗' : '○';
+    const color = state === 'pass' ? '\x1b[32m' : state === 'fail' ? '\x1b[31m' : '\x1b[33m';
+    const reset = '\x1b[0m';
+    
+    console.log(`${color}${status}${reset} ${task.name} (${duration.toFixed(0)}ms)`);
+
+    const suiteName = file ? path.basename(file.filepath, path.extname(file.filepath)) : 'unknown';
+    const caseName = task.name.replace(/[^a-zA-Z0-9-_]/g, '_');
+    const artifactURI = `reports/${suiteName}/${caseName}.jsonl`;
+
+    const summary: TestSummary = {
+      status: state,
+      duration,
+      location,
+      artifactURI,
+    };
+
+    if (result.errors && result.errors.length > 0) {
+      summary.error = result.errors.map(e => e.message || String(e)).join('; ');
+    }
+
+    if (this.summaryStream) {
+      this.summaryStream.write(JSON.stringify(summary) + '\n');
+    }
+  }
+}
diff --git a/vitest.config.ts b/vitest.config.ts
index 98339dc..ba94214 100644
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -8,5 +8,6 @@ export default defineConfig({
         singleFork: false,
       },
     },
+    reporters: ['./dist/test/reporter/jsonlReporter.js'],
   },
 });
