diff --git a/src/router/Federation.ts b/src/router/Federation.ts
new file mode 100644
index 0000000..ba938cb
--- /dev/null
+++ b/src/router/Federation.ts
@@ -0,0 +1,280 @@
+import { RoutingServer } from './RoutingServer.js';
+import type { RoutingAnnouncement, RoutingEndpoint } from '../types.js';
+import type { RouterEvent } from '../types/router.js';
+import { debug } from '../debug/api.js';
+
+/**
+ * PeerSource provides a list of peer router URLs for federation.
+ */
+export interface PeerSource {
+  getPeers(): Promise<string[]>;
+}
+
+/**
+ * ConfigPeerSource: Static list of peer routers from configuration.
+ */
+export class ConfigPeerSource implements PeerSource {
+  private peers: string[];
+
+  constructor(peers: string[]) {
+    this.peers = peers;
+  }
+
+  async getPeers(): Promise<string[]> {
+    return [...this.peers];
+  }
+}
+
+export interface FederationConfig {
+  routerId: string;
+  router: RoutingServer;
+  peerSource: PeerSource;
+  propagateIntervalMs?: number;
+}
+
+interface PeerConnection {
+  peerId: string;
+  url: string;
+  lastSeen: number;
+  active: boolean;
+}
+
+/**
+ * Federation manages router-to-router advertisement propagation.
+ * Routers share endpoint announcements and TTL information across the federation.
+ */
+export class Federation {
+  private routerId: string;
+  private router: RoutingServer;
+  private peerSource: PeerSource;
+  private peers = new Map<string, PeerConnection>();
+  private propagateIntervalMs: number;
+  private propagateTimer?: NodeJS.Timeout;
+  private unsubscribe?: () => void;
+  private localEndpoints = new Set<string>();
+
+  constructor(config: FederationConfig) {
+    this.routerId = config.routerId;
+    this.router = config.router;
+    this.peerSource = config.peerSource;
+    this.propagateIntervalMs = config.propagateIntervalMs ?? 5000;
+  }
+
+  /**
+   * Start federation: subscribe to local router changes and propagate to peers.
+   */
+  async start(): Promise<void> {
+    debug.emit('federation', 'start', { routerId: this.routerId });
+
+    // Subscribe to local router events
+    this.unsubscribe = this.router.subscribe((event: RouterEvent) => {
+      this.handleLocalEvent(event);
+    });
+
+    // Discover peers
+    await this.discoverPeers();
+
+    // Start periodic propagation
+    this.startPropagation();
+
+    debug.emit('federation', 'started', {
+      routerId: this.routerId,
+      peerCount: this.peers.size,
+    });
+  }
+
+  /**
+   * Stop federation: unsubscribe and clean up.
+   */
+  stop(): void {
+    debug.emit('federation', 'stop', { routerId: this.routerId });
+
+    if (this.unsubscribe) {
+      this.unsubscribe();
+      this.unsubscribe = undefined;
+    }
+
+    if (this.propagateTimer) {
+      clearInterval(this.propagateTimer);
+      this.propagateTimer = undefined;
+    }
+
+    this.peers.clear();
+    this.localEndpoints.clear();
+
+    debug.emit('federation', 'stopped', { routerId: this.routerId });
+  }
+
+  /**
+   * Handle local router events (added/updated/removed).
+   */
+  private handleLocalEvent(event: RouterEvent): void {
+    const { type, endpoint } = event;
+
+    // Track local endpoints (exclude peer-sourced endpoints)
+    const isLocal = !endpoint.metadata?.federationSource;
+
+    if (type === 'added' || type === 'updated') {
+      if (isLocal) {
+        this.localEndpoints.add(endpoint.id);
+        debug.emit('federation', 'local.change', {
+          type,
+          id: endpoint.id,
+          coordinates: endpoint.coordinates,
+        });
+      }
+    } else if (type === 'removed') {
+      this.localEndpoints.delete(endpoint.id);
+      debug.emit('federation', 'local.removed', { id: endpoint.id });
+    }
+  }
+
+  /**
+   * Discover peers from PeerSource.
+   */
+  private async discoverPeers(): Promise<void> {
+    try {
+      const peerUrls = await this.peerSource.getPeers();
+      const now = Date.now();
+
+      for (const url of peerUrls) {
+        const peerId = this.extractPeerId(url);
+        if (peerId === this.routerId) {
+          debug.emit('federation', 'peer.skip-self', { url });
+          continue;
+        }
+
+        if (!this.peers.has(peerId)) {
+          this.peers.set(peerId, {
+            peerId,
+            url,
+            lastSeen: now,
+            active: true,
+          });
+          debug.emit('federation', 'peer.discovered', { peerId, url });
+        }
+      }
+    } catch (err) {
+      debug.emit(
+        'federation',
+        'peer.discovery.error',
+        { error: err instanceof Error ? err.message : String(err) },
+        'error',
+      );
+    }
+  }
+
+  /**
+   * Extract peer ID from URL (e.g., "router-1" from "tcp://router-1:30020").
+   */
+  private extractPeerId(url: string): string {
+    // Simple extraction: use hostname from URL
+    const match = url.match(/^(?:tcp|ws):\/\/([^:\/]+)/);
+    return match ? match[1] : url;
+  }
+
+  /**
+   * Start periodic propagation of local endpoints to peers.
+   */
+  private startPropagation(): void {
+    if (this.propagateTimer) return;
+
+    this.propagateTimer = setInterval(() => {
+      this.propagateLocalEndpoints();
+    }, this.propagateIntervalMs);
+
+    // Initial propagation
+    this.propagateLocalEndpoints();
+  }
+
+  /**
+   * Propagate local endpoints to all active peers.
+   */
+  private propagateLocalEndpoints(): void {
+    const endpoints = this.router.list().filter((ep) => this.localEndpoints.has(ep.id));
+
+    if (endpoints.length === 0) {
+      debug.emit('federation', 'propagate.skip', { reason: 'no-local-endpoints' });
+      return;
+    }
+
+    debug.emit('federation', 'propagate.start', {
+      endpointCount: endpoints.length,
+      peerCount: this.peers.size,
+    });
+
+    for (const peer of this.peers.values()) {
+      if (!peer.active) continue;
+
+      this.propagateToPeer(peer, endpoints);
+    }
+  }
+
+  /**
+   * Propagate endpoints to a specific peer.
+   * TODO: Implement actual network transmission (TCP/WebSocket).
+   */
+  private propagateToPeer(peer: PeerConnection, endpoints: RoutingEndpoint[]): void {
+    // For now, just log the propagation
+    // In a real implementation, this would send announcements over TCP/WebSocket
+    debug.emit('federation', 'propagate.peer', {
+      peerId: peer.peerId,
+      url: peer.url,
+      endpointCount: endpoints.length,
+    });
+
+    // TODO: Send announcements to peer over network
+    // This will be implemented with actual TCP/WebSocket connections
+  }
+
+  /**
+   * Receive an announcement from a peer and inject into local router.
+   */
+  receiveFromPeer(peerId: string, announcement: RoutingAnnouncement): void {
+    // Mark announcement as coming from a peer
+    const peerAnnouncement: RoutingAnnouncement = {
+      ...announcement,
+      metadata: {
+        ...announcement.metadata,
+        federationSource: peerId,
+      },
+    };
+
+    debug.emit('federation', 'receive.peer', {
+      peerId,
+      id: announcement.id,
+      type: announcement.type,
+    });
+
+    // Inject into local router
+    this.router.announce(peerAnnouncement);
+
+    // Update peer last seen
+    const peer = this.peers.get(peerId);
+    if (peer) {
+      peer.lastSeen = Date.now();
+    }
+  }
+
+  /**
+   * Get federation status for monitoring.
+   */
+  getStatus(): {
+    routerId: string;
+    peerCount: number;
+    localEndpointCount: number;
+    peers: Array<{ peerId: string; url: string; active: boolean; lastSeen: number }>;
+  } {
+    return {
+      routerId: this.routerId,
+      peerCount: this.peers.size,
+      localEndpointCount: this.localEndpoints.size,
+      peers: Array.from(this.peers.values()).map((p) => ({
+        peerId: p.peerId,
+        url: p.url,
+        active: p.active,
+        lastSeen: p.lastSeen,
+      })),
+    };
+  }
+}
diff --git a/tests/integration/router.federation.spec.ts b/tests/integration/router.federation.spec.ts
new file mode 100644
index 0000000..6a241e7
--- /dev/null
+++ b/tests/integration/router.federation.spec.ts
@@ -0,0 +1,273 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import { RoutingServer } from '../../src/router/RoutingServer.js';
+import { Federation, ConfigPeerSource } from '../../src/router/Federation.js';
+
+describe('Router Federation', () => {
+  let router1: RoutingServer;
+  let router2: RoutingServer;
+  let federation1: Federation;
+  let federation2: Federation;
+
+  beforeEach(() => {
+    router1 = new RoutingServer({ ttlMs: 30000 });
+    router2 = new RoutingServer({ ttlMs: 30000 });
+  });
+
+  afterEach(() => {
+    federation1?.stop();
+    federation2?.stop();
+    router1?.stopSweeper();
+    router2?.stopSweeper();
+  });
+
+  it('creates federation with static peer source', async () => {
+    const peerSource1 = new ConfigPeerSource(['tcp://router-2:30020']);
+    federation1 = new Federation({
+      routerId: 'router-1',
+      router: router1,
+      peerSource: peerSource1,
+      propagateIntervalMs: 1000,
+    });
+
+    await federation1.start();
+
+    const status = federation1.getStatus();
+    expect(status.routerId).toBe('router-1');
+    expect(status.peerCount).toBe(1);
+    expect(status.peers[0].peerId).toBe('router-2');
+  });
+
+  it('tracks local endpoints separately from peer endpoints', async () => {
+    const peerSource1 = new ConfigPeerSource(['tcp://router-2:30020']);
+    federation1 = new Federation({
+      routerId: 'router-1',
+      router: router1,
+      peerSource: peerSource1,
+    });
+
+    await federation1.start();
+
+    // Announce local endpoint
+    router1.announce({
+      id: 'local-ep-1',
+      type: 'inproc',
+      coordinates: 'node:service-a',
+    });
+
+    // Simulate receiving from peer
+    federation1.receiveFromPeer('router-2', {
+      id: 'remote-ep-1',
+      type: 'inproc',
+      coordinates: 'node:service-b',
+    });
+
+    const status = federation1.getStatus();
+    expect(status.localEndpointCount).toBe(1);
+
+    const endpoints = router1.list();
+    expect(endpoints.length).toBe(2);
+
+    const localEndpoint = endpoints.find((ep) => ep.id === 'local-ep-1');
+    expect(localEndpoint).toBeDefined();
+    expect(localEndpoint?.metadata?.federationSource).toBeUndefined();
+
+    const remoteEndpoint = endpoints.find((ep) => ep.id === 'remote-ep-1');
+    expect(remoteEndpoint).toBeDefined();
+    expect(remoteEndpoint?.metadata?.federationSource).toBe('router-2');
+  });
+
+  it('propagates local announcements to peers', async () => {
+    const peerSource1 = new ConfigPeerSource(['tcp://router-2:30020']);
+    federation1 = new Federation({
+      routerId: 'router-1',
+      router: router1,
+      peerSource: peerSource1,
+      propagateIntervalMs: 100,
+    });
+
+    await federation1.start();
+
+    // Announce local endpoint
+    router1.announce({
+      id: 'local-ep-1',
+      type: 'inproc',
+      coordinates: 'node:service-a',
+    });
+
+    // Wait for propagation cycle
+    await new Promise((resolve) => setTimeout(resolve, 200));
+
+    const status = federation1.getStatus();
+    expect(status.localEndpointCount).toBe(1);
+  });
+
+  it('handles multiple peers', async () => {
+    const peerSource1 = new ConfigPeerSource([
+      'tcp://router-2:30020',
+      'tcp://router-3:30020',
+      'tcp://router-4:30020',
+    ]);
+
+    federation1 = new Federation({
+      routerId: 'router-1',
+      router: router1,
+      peerSource: peerSource1,
+    });
+
+    await federation1.start();
+
+    const status = federation1.getStatus();
+    expect(status.peerCount).toBe(3);
+    expect(status.peers.map((p) => p.peerId)).toEqual([
+      'router-2',
+      'router-3',
+      'router-4',
+    ]);
+  });
+
+  it('skips self when listed as peer', async () => {
+    const peerSource1 = new ConfigPeerSource([
+      'tcp://router-1:30020', // Self
+      'tcp://router-2:30020',
+    ]);
+
+    federation1 = new Federation({
+      routerId: 'router-1',
+      router: router1,
+      peerSource: peerSource1,
+    });
+
+    await federation1.start();
+
+    const status = federation1.getStatus();
+    expect(status.peerCount).toBe(1); // Only router-2, not self
+    expect(status.peers[0].peerId).toBe('router-2');
+  });
+
+  it('simulates two-router federation', async () => {
+    // Router 1 setup
+    const peerSource1 = new ConfigPeerSource(['tcp://router-2:30020']);
+    federation1 = new Federation({
+      routerId: 'router-1',
+      router: router1,
+      peerSource: peerSource1,
+    });
+
+    // Router 2 setup
+    const peerSource2 = new ConfigPeerSource(['tcp://router-1:30020']);
+    federation2 = new Federation({
+      routerId: 'router-2',
+      router: router2,
+      peerSource: peerSource2,
+    });
+
+    await federation1.start();
+    await federation2.start();
+
+    // Router 1 announces local endpoint
+    router1.announce({
+      id: 'r1-service-a',
+      type: 'inproc',
+      coordinates: 'node:service-a',
+    });
+
+    // Router 2 announces local endpoint
+    router2.announce({
+      id: 'r2-service-b',
+      type: 'inproc',
+      coordinates: 'node:service-b',
+    });
+
+    // Simulate cross-propagation
+    // In real implementation, this would happen via network
+    const r1Endpoints = router1.list().filter((ep) => !ep.metadata?.federationSource);
+    for (const ep of r1Endpoints) {
+      federation2.receiveFromPeer('router-1', {
+        id: ep.id,
+        type: ep.type,
+        coordinates: ep.coordinates,
+        metadata: ep.metadata,
+      });
+    }
+
+    const r2Endpoints = router2.list().filter((ep) => !ep.metadata?.federationSource);
+    for (const ep of r2Endpoints) {
+      federation1.receiveFromPeer('router-2', {
+        id: ep.id,
+        type: ep.type,
+        coordinates: ep.coordinates,
+        metadata: ep.metadata,
+      });
+    }
+
+    // Verify router 1 has both local and remote
+    const r1List = router1.list();
+    expect(r1List.length).toBe(2);
+    expect(r1List.find((ep) => ep.id === 'r1-service-a')).toBeDefined();
+    expect(r1List.find((ep) => ep.id === 'r2-service-b')).toBeDefined();
+    expect(r1List.find((ep) => ep.id === 'r2-service-b')?.metadata?.federationSource).toBe(
+      'router-2',
+    );
+
+    // Verify router 2 has both local and remote
+    const r2List = router2.list();
+    expect(r2List.length).toBe(2);
+    expect(r2List.find((ep) => ep.id === 'r2-service-b')).toBeDefined();
+    expect(r2List.find((ep) => ep.id === 'r1-service-a')).toBeDefined();
+    expect(r2List.find((ep) => ep.id === 'r1-service-a')?.metadata?.federationSource).toBe(
+      'router-1',
+    );
+  });
+
+  it('removes local endpoints when withdrawn', async () => {
+    const peerSource1 = new ConfigPeerSource(['tcp://router-2:30020']);
+    federation1 = new Federation({
+      routerId: 'router-1',
+      router: router1,
+      peerSource: peerSource1,
+    });
+
+    await federation1.start();
+
+    router1.announce({
+      id: 'local-ep-1',
+      type: 'inproc',
+      coordinates: 'node:service-a',
+    });
+
+    expect(federation1.getStatus().localEndpointCount).toBe(1);
+
+    router1.withdraw('local-ep-1');
+
+    expect(federation1.getStatus().localEndpointCount).toBe(0);
+  });
+
+  it('updates peer lastSeen when receiving announcements', async () => {
+    const peerSource1 = new ConfigPeerSource(['tcp://router-2:30020']);
+    federation1 = new Federation({
+      routerId: 'router-1',
+      router: router1,
+      peerSource: peerSource1,
+    });
+
+    await federation1.start();
+
+    const statusBefore = federation1.getStatus();
+    const initialLastSeen = statusBefore.peers[0].lastSeen;
+
+    // Wait a bit
+    await new Promise((resolve) => setTimeout(resolve, 50));
+
+    // Receive announcement from peer
+    federation1.receiveFromPeer('router-2', {
+      id: 'remote-ep-1',
+      type: 'inproc',
+      coordinates: 'node:service-b',
+    });
+
+    const statusAfter = federation1.getStatus();
+    const updatedLastSeen = statusAfter.peers[0].lastSeen;
+
+    expect(updatedLastSeen).toBeGreaterThan(initialLastSeen);
+  });
+});
