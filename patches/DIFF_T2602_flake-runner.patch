diff --git a/scripts/laminar-run.ts b/scripts/laminar-run.ts
index 6aad0c3..b726ab1 100644
--- a/scripts/laminar-run.ts
+++ b/scripts/laminar-run.ts
@@ -10,11 +10,24 @@ type SummaryEntry = {
   error?: string;
 };
 
+type StabilityResult = {
+  location: string;
+  runs: number;
+  passes: number;
+  fails: number;
+  score: number; // percentage 0-100
+};
+
 function run(cmd: string, args: string[], env?: Record<string,string>) {
   const res = spawnSync(cmd, args, { stdio: 'inherit', env: { ...process.env, ...env } });
   return res.status ?? 0;
 }
 
+function runSilent(cmd: string, args: string[], env?: Record<string,string>) {
+  const res = spawnSync(cmd, args, { stdio: 'pipe', env: { ...process.env, ...env } });
+  return res.status ?? 0;
+}
+
 function parseSummary(): SummaryEntry[] {
   const path = 'reports/summary.jsonl';
   if (!fs.existsSync(path)) return [];
@@ -38,7 +51,119 @@ function caseFromArtifact(uri?: string): string {
   return m ? m[1] : 'debug.case';
 }
 
+async function runFlakeDetection(reruns: number = 5) {
+  console.log(`\n=== FLAKE DETECTION MODE (${reruns} runs per test) ===\n`);
+  
+  fs.mkdirSync('reports', { recursive: true });
+  
+  // Use fixed seed for reproducibility
+  const seed = '42';
+  const env = { VITEST_SEED: seed };
+  
+  const stabilityMap = new Map<string, StabilityResult>();
+  
+  for (let i = 1; i <= reruns; i++) {
+    console.log(`\nRun ${i}/${reruns} (seed: ${seed})...`);
+    
+    // Clean summary before each run
+    if (fs.existsSync('reports/summary.jsonl')) fs.unlinkSync('reports/summary.jsonl');
+    
+    // Run tests silently after first run
+    if (i === 1) {
+      run('npm', ['run', 'test:ci'], env);
+    } else {
+      runSilent('npm', ['run', 'test:ci'], env);
+    }
+    
+    const entries = parseSummary();
+    
+    // Track stability for each test
+    for (const entry of entries) {
+      if (entry.status === 'skip') continue;
+      
+      const loc = entry.location;
+      if (!stabilityMap.has(loc)) {
+        stabilityMap.set(loc, { location: loc, runs: 0, passes: 0, fails: 0, score: 0 });
+      }
+      
+      const stat = stabilityMap.get(loc)!;
+      stat.runs++;
+      if (entry.status === 'pass') {
+        stat.passes++;
+      } else if (entry.status === 'fail') {
+        stat.fails++;
+      }
+    }
+  }
+  
+  // Calculate final scores
+  const results: StabilityResult[] = [];
+  for (const stat of stabilityMap.values()) {
+    stat.score = Math.round((stat.passes / stat.runs) * 100);
+    results.push(stat);
+  }
+  
+  // Sort by score (flakiest first)
+  results.sort((a, b) => a.score - b.score);
+  
+  // Report findings
+  console.log('\n=== STABILITY REPORT ===\n');
+  
+  const flakyTests = results.filter(r => r.score < 100 && r.score > 0);
+  const alwaysFail = results.filter(r => r.score === 0);
+  const stable = results.filter(r => r.score === 100);
+  
+  if (flakyTests.length > 0) {
+    console.log('FLAKY TESTS:');
+    for (const t of flakyTests) {
+      console.log(`  ${t.score}% stable - ${t.location} (${t.passes}/${t.runs} passed)`);
+    }
+    console.log('');
+  }
+  
+  if (alwaysFail.length > 0) {
+    console.log('ALWAYS FAIL:');
+    for (const t of alwaysFail) {
+      console.log(`  ${t.location} (0/${t.runs} passed)`);
+    }
+    console.log('');
+  }
+  
+  console.log(`SUMMARY: ${stable.length} stable, ${flakyTests.length} flaky, ${alwaysFail.length} always fail`);
+  
+  // Save detailed report
+  const reportPath = 'reports/stability-report.json';
+  fs.writeFileSync(reportPath, JSON.stringify({ 
+    seed,
+    reruns,
+    timestamp: new Date().toISOString(),
+    results 
+  }, null, 2));
+  console.log(`\nDetailed report saved to ${reportPath}`);
+  
+  // Exit with error if any flaky tests found
+  if (flakyTests.length > 0 || alwaysFail.length > 0) {
+    process.exit(1);
+  }
+  
+  process.exit(0);
+}
+
 async function main() {
+  // Check for flake detection mode
+  const args = process.argv.slice(2);
+  const flakeDetectIdx = args.findIndex(a => a === '--flake-detect' || a === '--flake');
+  
+  if (flakeDetectIdx !== -1) {
+    // Parse N reruns (default 5)
+    let reruns = 5;
+    if (flakeDetectIdx + 1 < args.length && /^\d+$/.test(args[flakeDetectIdx + 1])) {
+      reruns = parseInt(args[flakeDetectIdx + 1], 10);
+    }
+    await runFlakeDetection(reruns);
+    return;
+  }
+  
   // First pass: fast lane
   fs.mkdirSync('reports', { recursive: true });
   // Clean previous summary
