diff --git a/tests/integration/stdioPath.spec.ts b/tests/integration/stdioPath.spec.ts
new file mode 100644
index 0000000..102a82e
--- /dev/null
+++ b/tests/integration/stdioPath.spec.ts
@@ -0,0 +1,260 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import { Kernel } from '../../src/kernel/Kernel.js';
+import { Hostess } from '../../src/hostess/Hostess.js';
+import { ExternalServerWrapper } from '../../src/wrappers/ExternalServerWrapper.js';
+import type { ExternalServerManifest } from '../../src/types.js';
+
+/**
+ * StdIO Path Integration Tests
+ * 
+ * Tests the StdIO communication path using ExternalServerWrapper.
+ * Run in forks/PTY lane via: npm run test:pty
+ * 
+ * Coverage:
+ * - Roundtrip (stdin → stdout)
+ * - Drain behavior (backpressure)
+ * - Lifecycle (start/stop)
+ * - Hostess endpoint registration (type: external, metadata.ioMode: stdio)
+ */
+describe('StdIO Path Integration', () => {
+  let kernel: Kernel;
+  let hostess: Hostess;
+  let wrapper: ExternalServerWrapper;
+
+  const testTimeout = 10000;
+
+  beforeEach(() => {
+    kernel = new Kernel();
+    hostess = new Hostess();
+  });
+
+  afterEach(async () => {
+    if (wrapper && wrapper.isRunning()) {
+      await wrapper.shutdown();
+    }
+  });
+
+  it('should perform stdin → stdout roundtrip', async () => {
+    const manifest: ExternalServerManifest = {
+      fqdn: 'localhost',
+      servername: 'cat-stdio',
+      classHex: '0xCAT1',
+      owner: 'test',
+      auth: 'no',
+      authMechanism: 'none',
+      terminals: [
+        { name: 'input', type: 'local', direction: 'input' },
+        { name: 'output', type: 'local', direction: 'output' }
+      ],
+      capabilities: {
+        type: 'transform',
+        accepts: ['text'],
+        produces: ['text']
+      },
+      command: '/bin/cat',
+      args: [],
+      env: {},
+      cwd: process.cwd(),
+      ioMode: 'stdio',
+      restart: 'never'
+    };
+
+    wrapper = new ExternalServerWrapper(kernel, hostess, manifest);
+    await wrapper.spawn();
+
+    const output: Buffer[] = [];
+    wrapper.outputPipe.on('data', (data) => output.push(Buffer.from(data)));
+
+    const testMessage = 'Hello StdIO\n';
+    wrapper.inputPipe.write(testMessage);
+
+    await new Promise(resolve => setTimeout(resolve, 300));
+
+    const received = Buffer.concat(output).toString();
+    expect(received).toBe(testMessage);
+  }, testTimeout);
+
+  it('should handle drain events under backpressure', async () => {
+    const manifest: ExternalServerManifest = {
+      fqdn: 'localhost',
+      servername: 'cat-drain',
+      classHex: '0xCAT2',
+      owner: 'test',
+      auth: 'no',
+      authMechanism: 'none',
+      terminals: [
+        { name: 'input', type: 'local', direction: 'input' },
+        { name: 'output', type: 'local', direction: 'output' }
+      ],
+      capabilities: {
+        type: 'transform'
+      },
+      command: '/bin/cat',
+      args: [],
+      env: {},
+      cwd: process.cwd(),
+      ioMode: 'stdio',
+      restart: 'never'
+    };
+
+    wrapper = new ExternalServerWrapper(kernel, hostess, manifest);
+    await wrapper.spawn();
+
+    const chunkSize = 64 * 1024;
+    const numChunks = 50;
+    const testData: Buffer[] = [];
+    
+    for (let i = 0; i < numChunks; i++) {
+      testData.push(Buffer.alloc(chunkSize, i % 256));
+    }
+
+    const receivedChunks: Buffer[] = [];
+    let drainEvents = 0;
+
+    wrapper.outputPipe.on('data', (chunk) => {
+      receivedChunks.push(Buffer.from(chunk));
+    });
+
+    for (let i = 0; i < testData.length; i++) {
+      const canContinue = wrapper.inputPipe.write(testData[i]);
+      if (!canContinue) {
+        drainEvents++;
+        await new Promise<void>((resolve) => {
+          wrapper.inputPipe.once('drain', resolve);
+        });
+      }
+    }
+    wrapper.inputPipe.end();
+
+    await new Promise<void>((resolve) => {
+      wrapper.outputPipe.once('end', resolve);
+    });
+
+    const receivedBuffer = Buffer.concat(receivedChunks);
+    const expectedBuffer = Buffer.concat(testData);
+    expect(receivedBuffer.length).toBe(expectedBuffer.length);
+    expect(receivedBuffer.equals(expectedBuffer)).toBe(true);
+    expect(drainEvents).toBeGreaterThan(0);
+  }, testTimeout);
+
+  it('should manage lifecycle (start/stop)', async () => {
+    const manifest: ExternalServerManifest = {
+      fqdn: 'localhost',
+      servername: 'cat-lifecycle',
+      classHex: '0xCAT3',
+      owner: 'test',
+      auth: 'no',
+      authMechanism: 'none',
+      terminals: [
+        { name: 'input', type: 'local', direction: 'input' },
+        { name: 'output', type: 'local', direction: 'output' }
+      ],
+      capabilities: {
+        type: 'transform'
+      },
+      command: '/bin/cat',
+      args: [],
+      env: {},
+      cwd: process.cwd(),
+      ioMode: 'stdio',
+      restart: 'never'
+    };
+
+    wrapper = new ExternalServerWrapper(kernel, hostess, manifest);
+    
+    expect(wrapper.isRunning()).toBe(false);
+
+    await wrapper.spawn();
+    expect(wrapper.isRunning()).toBe(true);
+    expect(wrapper.getProcessInfo().pid).toBeGreaterThan(0);
+
+    await wrapper.shutdown();
+    expect(wrapper.isRunning()).toBe(false);
+  }, testTimeout);
+
+  it('should register with Hostess correctly', async () => {
+    const manifest: ExternalServerManifest = {
+      fqdn: 'localhost',
+      servername: 'cat-hostess',
+      classHex: '0xCAT4',
+      owner: 'test',
+      auth: 'no',
+      authMechanism: 'none',
+      terminals: [
+        { name: 'input', type: 'local', direction: 'input' }
+      ],
+      capabilities: {
+        type: 'output'
+      },
+      command: '/bin/cat',
+      args: [],
+      env: {},
+      cwd: process.cwd(),
+      ioMode: 'stdio',
+      restart: 'never'
+    };
+
+    wrapper = new ExternalServerWrapper(kernel, hostess, manifest);
+    await wrapper.spawn();
+
+    const servers = hostess.list();
+    const found = servers.find(s => s.servername === 'cat-hostess');
+    
+    expect(found).toBeDefined();
+    expect(found?.servername).toBe('cat-hostess');
+
+    const endpoints = hostess.listEndpoints();
+    const endpoint = Array.from(endpoints.entries()).find(
+      ([_, ep]) => ep.coordinates === '/bin/cat '
+    );
+
+    expect(endpoint).toBeDefined();
+    expect(endpoint![1].type).toBe('external');
+    expect(endpoint![1].metadata?.ioMode).toBe('stdio');
+    expect(endpoint![1].metadata?.cwd).toBe(process.cwd());
+  }, testTimeout);
+
+  it('should handle multiple sequential messages', async () => {
+    const manifest: ExternalServerManifest = {
+      fqdn: 'localhost',
+      servername: 'cat-sequential',
+      classHex: '0xCAT5',
+      owner: 'test',
+      auth: 'no',
+      authMechanism: 'none',
+      terminals: [
+        { name: 'input', type: 'local', direction: 'input' },
+        { name: 'output', type: 'local', direction: 'output' }
+      ],
+      capabilities: {
+        type: 'transform'
+      },
+      command: '/bin/cat',
+      args: [],
+      env: {},
+      cwd: process.cwd(),
+      ioMode: 'stdio',
+      restart: 'never'
+    };
+
+    wrapper = new ExternalServerWrapper(kernel, hostess, manifest);
+    await wrapper.spawn();
+
+    const output: Buffer[] = [];
+    wrapper.outputPipe.on('data', (data) => output.push(Buffer.from(data)));
+
+    const messages = ['message1\n', 'message2\n', 'message3\n'];
+    
+    for (const msg of messages) {
+      wrapper.inputPipe.write(msg);
+      await new Promise(resolve => setTimeout(resolve, 100));
+    }
+
+    await new Promise(resolve => setTimeout(resolve, 300));
+
+    const received = Buffer.concat(output).toString();
+    messages.forEach(msg => {
+      expect(received).toContain(msg.trim());
+    });
+  }, testTimeout);
+});
diff --git a/package.json b/package.json
index e3a7fb8..c4fff5f 100644
--- a/package.json
+++ b/package.json
@@ -43,7 +43,7 @@
     "build": "tsc -p tsconfig.json",
     "test": "vitest run",
     "test:ci": "vitest run --pool=threads --exclude='**/{ptyServerWrapper,multiModalOutput,endpointsList,processMode}.spec.ts' --reporter=./node_modules/@agent_vega/laminar/dist/src/test/reporter/jsonlReporter.js",
-    "test:pty": "vitest run --pool=forks --poolOptions.forks.singleFork=true tests/wrappers/ptyServerWrapper.spec.ts tests/integration/multiModalOutput.spec.ts tests/integration/endpointsList.spec.ts tests/integration/processMode.spec.ts tests/integration/processUnix.spec.ts tests/integration/workerMode.spec.ts --reporter=./node_modules/@agent_vega/laminar/dist/src/test/reporter/jsonlReporter.js",
+    "test:pty": "vitest run --pool=forks --poolOptions.forks.singleFork=true tests/wrappers/ptyServerWrapper.spec.ts tests/integration/multiModalOutput.spec.ts tests/integration/endpointsList.spec.ts tests/integration/processMode.spec.ts tests/integration/processUnix.spec.ts tests/integration/workerMode.spec.ts tests/integration/stdioPath.spec.ts --reporter=./node_modules/@agent_vega/laminar/dist/src/test/reporter/jsonlReporter.js",
     "test:ci:lam": "npm run test:ci && mkdir -p reports && npm run lam -- summary > reports/LAMINAR_SUMMARY.txt && npm run lam -- trends --top 10 > reports/LAMINAR_TRENDS.txt",
     "test:pty:lam": "MK_PROCESS_EXPERIMENTAL=1 npm run test:pty && mkdir -p reports && npm run lam -- summary >> reports/LAMINAR_SUMMARY.txt && npm run lam -- trends --top 10 >> reports/LAMINAR_TRENDS.txt",
     "lam:dogfood:ci": "tsx scripts/dogfood-ci.ts",
