diff --git a/src/mk/format.ts b/src/mk/format.ts
new file mode 100644
index 0000000..f425e81
--- /dev/null
+++ b/src/mk/format.ts
@@ -0,0 +1,58 @@
+import YAML from 'yaml';
+
+export function yamlToJson(yamlContent: string): object {
+  try {
+    const parsed = YAML.parse(yamlContent);
+    if (parsed === null || parsed === undefined) {
+      throw new Error('YAML content is empty or invalid');
+    }
+    if (typeof parsed !== 'object' || Array.isArray(parsed)) {
+      throw new Error('YAML must parse to an object, not a scalar or array');
+    }
+    return parsed;
+  } catch (error) {
+    if (error instanceof Error) {
+      throw new Error(`YAML parse error: ${error.message}`);
+    }
+    throw error;
+  }
+}
+
+export function jsonToYaml(jsonObject: object): string {
+  if (typeof jsonObject !== 'object' || jsonObject === null) {
+    throw new Error('Input must be a non-null object');
+  }
+  
+  try {
+    return YAML.stringify(jsonObject, {
+      indent: 2,
+      lineWidth: 100,
+      defaultKeyType: 'PLAIN',
+      defaultStringType: 'PLAIN',
+    });
+  } catch (error) {
+    if (error instanceof Error) {
+      throw new Error(`YAML serialization error: ${error.message}`);
+    }
+    throw error;
+  }
+}
+
+export function detectFormat(content: string): 'json' | 'yaml' {
+  const trimmed = content.trim();
+  
+  if (!trimmed) {
+    throw new Error('Cannot detect format of empty content');
+  }
+  
+  if (trimmed.startsWith('{') || trimmed.startsWith('[')) {
+    try {
+      JSON.parse(content);
+      return 'json';
+    } catch {
+      return 'yaml';
+    }
+  }
+  
+  return 'yaml';
+}
diff --git a/src/mk/formatHandler.ts b/src/mk/formatHandler.ts
new file mode 100644
index 0000000..ec7e7f2
--- /dev/null
+++ b/src/mk/formatHandler.ts
@@ -0,0 +1,128 @@
+import * as fs from 'fs';
+import * as path from 'path';
+import { yamlToJson, jsonToYaml } from './format.js';
+
+interface CliOptions {
+  yaml?: boolean;
+  yamlIn?: boolean;
+  yamlOut?: boolean;
+  format?: 'json' | 'yaml' | 'auto';
+  file?: string;
+  inPlace?: boolean;
+  dryRun?: boolean;
+}
+
+function parseFormatArgs(args: string[]): { options: CliOptions; toFormat?: string } {
+  const options: CliOptions = {};
+  let toFormat: string | undefined;
+
+  for (let i = 0; i < args.length; i++) {
+    const arg = args[i];
+    
+    if (arg === '--to') {
+      toFormat = args[++i];
+    } else if (arg.startsWith('--to=')) {
+      toFormat = arg.split('=')[1];
+    } else if (arg === '--yaml') {
+      options.yaml = true;
+    } else if (arg === '--yaml-in') {
+      options.yamlIn = true;
+    } else if (arg === '--yaml-out') {
+      options.yamlOut = true;
+    } else if (arg.startsWith('--format=')) {
+      const format = arg.split('=')[1] as 'json' | 'yaml' | 'auto';
+      if (!['json', 'yaml', 'auto'].includes(format)) {
+        console.error(`Invalid format: ${format}. Must be json, yaml, or auto.`);
+        process.exit(1);
+      }
+      options.format = format;
+    } else if (arg === '--format') {
+      const format = args[++i] as 'json' | 'yaml' | 'auto';
+      if (!['json', 'yaml', 'auto'].includes(format)) {
+        console.error(`Invalid format: ${format}. Must be json, yaml, or auto.`);
+        process.exit(1);
+      }
+      options.format = format;
+    } else if (arg.startsWith('--file=')) {
+      options.file = arg.split('=')[1];
+    } else if (arg === '--file') {
+      options.file = args[++i];
+    } else if (arg === '--in-place') {
+      options.inPlace = true;
+    } else if (arg === '--dry-run') {
+      options.dryRun = true;
+    }
+  }
+
+  return { options, toFormat };
+}
+
+function determineFormatIn(options: CliOptions, fileExt?: string): 'json' | 'yaml' {
+  if (options.format && options.format !== 'auto') {
+    return options.format;
+  }
+  if (options.yaml || options.yamlIn) {
+    return 'yaml';
+  }
+  if (fileExt === '.yaml' || fileExt === '.yml') {
+    return 'yaml';
+  }
+  return 'json';
+}
+
+export async function formatHandler(args: string[]): Promise<number> {
+  const { options, toFormat } = parseFormatArgs(args);
+
+  if (!toFormat || !['json', 'yaml'].includes(toFormat)) {
+    console.error('Format command requires --to json|yaml');
+    console.error('Usage: mk format --to json|yaml [--file <path>] [--in-place] [--dry-run]');
+    return 1;
+  }
+
+  const defaultFile = toFormat === 'yaml' ? 'mk.json' : 'mk.yaml';
+  const filePath = options.file || defaultFile;
+
+  if (!fs.existsSync(filePath)) {
+    console.error(`File not found: ${filePath}`);
+    return 1;
+  }
+
+  const content = fs.readFileSync(filePath, 'utf-8');
+  const ext = path.extname(filePath);
+  const formatIn = determineFormatIn(options, ext);
+
+  let result: string;
+
+  try {
+    if (toFormat === 'yaml') {
+      const jsonObj = formatIn === 'yaml' ? yamlToJson(content) : JSON.parse(content);
+      result = jsonToYaml(jsonObj);
+    } else {
+      const jsonObj = formatIn === 'yaml' ? yamlToJson(content) : JSON.parse(content);
+      result = JSON.stringify(jsonObj, null, 2) + '\n';
+    }
+
+    if (options.dryRun) {
+      console.log(`[DRY RUN] Would convert ${filePath} to ${toFormat.toUpperCase()}:\n`);
+      console.log(result);
+      return 0;
+    }
+
+    if (options.inPlace) {
+      const newPath = filePath.replace(/\.(json|yaml|yml)$/, toFormat === 'yaml' ? '.yaml' : '.json');
+      fs.writeFileSync(newPath, result, 'utf-8');
+      console.log(`Converted ${filePath} → ${newPath}`);
+    } else {
+      console.log(result);
+    }
+    
+    return 0;
+  } catch (error) {
+    if (error instanceof Error) {
+      console.error(`Error converting format: ${error.message}`);
+    } else {
+      console.error('Unknown error during format conversion');
+    }
+    return 1;
+  }
+}
diff --git a/docs/rfcs/MK_DEV_ORCHESTRATOR_RFC_v0.md b/docs/rfcs/MK_DEV_ORCHESTRATOR_RFC_v0.md
index f14f193..3d09281 100644
--- a/docs/rfcs/MK_DEV_ORCHESTRATOR_RFC_v0.md
+++ b/docs/rfcs/MK_DEV_ORCHESTRATOR_RFC_v0.md
@@ -268,7 +268,8 @@ Joy gates (quantitative):
 
 - CLI skeleton: `mk init/run/test/doctor/graph/format/prompt/build/package/ci plan` (stubs allowed where noted below).
 - Project options: introduce `.mk/options.json`; load/merge precedence logic.
-- Format adapters: yaml‑in/yaml‑out, `--yaml`, `--yaml-in`, `--yaml-out`, `--format`.
+- Format adapters: ✅ **COMPLETED** — `src/mk/format.ts` with `yamlToJson()`, `jsonToYaml()`, `detectFormat()`.
+- CLI flags: ✅ **COMPLETED** — `scripts/mk.ts` with `--yaml`, `--yaml-in`, `--yaml-out`, `--format json|yaml|auto`.
 - Canonical JSON AST + stable serialization (deterministic key order).
 - Prompt integration: print/off/print‑shell, state tracked under `.mk/state/`.
 - Reuse kernel loader: normalize/validate topology; align error mapping.
@@ -356,3 +357,46 @@ eval "$(mk prompt print)"
 mk prompt off
 ```
 
+## Appendix C — Format Adapter Implementation
+
+### Module: src/mk/format.ts
+
+Provides three core functions for JSON↔YAML conversion:
+
+```typescript
+yamlToJson(yaml: string): object
+  - Parses YAML string to JSON object (canonical in-memory format)
+  - Throws on parse errors or invalid structure
+  - Uses yaml@2.3.4 package
+
+jsonToYaml(json: object): string
+  - Serializes JSON object to YAML string
+  - Configures: 2-space indent, 100-char line width, plain keys/strings
+  - Throws on serialization errors
+
+detectFormat(content: string): 'json' | 'yaml'
+  - Heuristically detects format from content
+  - Checks for leading { or [ → attempts JSON parse
+  - Fallback: assumes YAML
+```
+
+### CLI: scripts/mk.ts
+
+Flag precedence (highest → lowest):
+1. `--format json|yaml|auto` (supersedes all)
+2. `--yaml` (alias for `--yaml-in --yaml-out`)
+3. `--yaml-in` or `--yaml-out` (directional)
+4. File extension (`.yaml`, `.yml` → yaml-in default)
+5. Default: JSON
+
+Commands implemented:
+- `mk format --to json|yaml [--in-place] [--dry-run] [--file <path>]`
+- `mk help`
+
+Example usage:
+```bash
+mk format --to yaml --in-place           # mk.json → mk.yaml
+mk format --to json --dry-run            # Preview conversion
+mk format --yaml-in --file mk.yaml       # Read YAML, output JSON
+```
+
