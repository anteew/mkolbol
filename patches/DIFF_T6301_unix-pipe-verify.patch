diff --git a/src/transport/unix/UnixPipeAdapter.ts b/src/transport/unix/UnixPipeAdapter.ts
new file mode 100644
index 0000000..86cf5dc
--- /dev/null
+++ b/src/transport/unix/UnixPipeAdapter.ts
@@ -0,0 +1,160 @@
+import { Duplex } from 'stream';
+import { Socket, Server, createServer, createConnection } from 'node:net';
+import type { Pipe, StreamOptions } from '../../types/stream.js';
+
+interface ProcessPipeAdapter {
+  createDuplex(options?: StreamOptions): Pipe;
+  listen(): Promise<void>;
+  connect(): Promise<void>;
+  close(): void;
+}
+
+interface UnixPipeAdapterOptions extends StreamOptions {
+  socket: Socket;
+}
+
+class UnixPipeAdapterDuplex extends Duplex {
+  private socket: Socket;
+  private isClosing: boolean = false;
+
+  constructor(options: UnixPipeAdapterOptions) {
+    const { socket, ...streamOptions } = options;
+    super(streamOptions);
+    this.socket = socket;
+
+    this.socket.on('data', (data: Buffer) => {
+      if (!this.push(data)) {
+        this.socket.pause();
+      }
+    });
+
+    this.socket.on('end', () => {
+      this.push(null);
+    });
+
+    this.socket.on('error', (err: Error) => {
+      this.destroy(err);
+    });
+
+    this.socket.on('close', () => {
+      if (!this.isClosing) {
+        this.destroy();
+      }
+    });
+  }
+
+  _read(size: number): void {
+    this.socket.resume();
+  }
+
+  _write(
+    chunk: any,
+    encoding: BufferEncoding,
+    callback: (error?: Error | null) => void
+  ): void {
+    const canContinue = this.socket.write(chunk, encoding, (err) => {
+      if (err) {
+        callback(err);
+      }
+    });
+
+    if (canContinue) {
+      callback();
+    } else {
+      this.socket.once('drain', () => {
+        callback();
+      });
+    }
+  }
+
+  _final(callback: (error?: Error | null) => void): void {
+    this.socket.end(() => {
+      callback();
+    });
+  }
+
+  _destroy(
+    error: Error | null,
+    callback: (error?: Error | null) => void
+  ): void {
+    this.isClosing = true;
+    if (!this.socket.destroyed) {
+      this.socket.destroy();
+    }
+    callback(error);
+  }
+}
+
+export class UnixPipeAdapter implements ProcessPipeAdapter {
+  private socketPath: string;
+  private server?: Server;
+  private socket?: Socket;
+  private isListening: boolean = false;
+  private isConnected: boolean = false;
+
+  constructor(socketPath: string) {
+    this.socketPath = socketPath;
+  }
+
+  async listen(): Promise<void> {
+    if (this.isListening) {
+      return;
+    }
+
+    return new Promise((resolve, reject) => {
+      this.server = createServer((socket) => {
+        this.socket = socket;
+      });
+
+      this.server.on('error', (err) => {
+        reject(err);
+      });
+
+      this.server.listen(this.socketPath, () => {
+        this.isListening = true;
+        resolve();
+      });
+    });
+  }
+
+  async connect(): Promise<void> {
+    if (this.isConnected) {
+      return;
+    }
+
+    return new Promise((resolve, reject) => {
+      const socket = createConnection(this.socketPath);
+
+      socket.on('connect', () => {
+        this.socket = socket;
+        this.isConnected = true;
+        resolve();
+      });
+
+      socket.on('error', (err) => {
+        reject(err);
+      });
+    });
+  }
+
+  createDuplex(options?: StreamOptions): Pipe {
+    if (!this.socket) {
+      throw new Error('Socket not initialized. Call listen() or connect() first.');
+    }
+    return new UnixPipeAdapterDuplex({
+      ...(options ?? {}),
+      socket: this.socket,
+    });
+  }
+
+  close(): void {
+    if (this.socket && !this.socket.destroyed) {
+      this.socket.destroy();
+    }
+    if (this.server) {
+      this.server.close();
+    }
+    this.isListening = false;
+    this.isConnected = false;
+  }
+}
