diff --git a/scripts/mkctl.ts b/scripts/mkctl.ts
index 37c3bae..fb7d5c8 100644
--- a/scripts/mkctl.ts
+++ b/scripts/mkctl.ts
@@ -103,25 +103,27 @@ main().catch(e => {
 interface RunArguments {
   configPath: string;
   durationMs: number;
+  snapshotIntervalMs?: number;
 }
 
 function parseRunArgs(args: string[]): RunArguments {
   let configPath: string | undefined;
   let durationMs = 5000;
+  let snapshotIntervalMs: number | undefined;
 
   for (let i = 0; i < args.length; i++) {
     const token = args[i];
     if (token === '--file') {
       const next = args[i + 1];
       if (!next || next.startsWith('--')) {
-        throw new MkctlError('Usage: mkctl run --file <path> [--duration <seconds>]', EXIT_CODES.USAGE);
+        throw new MkctlError('Usage: mkctl run --file <path> [--duration <seconds>] [--snapshot-interval <seconds>]', EXIT_CODES.USAGE);
       }
       configPath = next;
       i++;
     } else if (token === '--duration') {
       const next = args[i + 1];
       if (!next || next.startsWith('--')) {
-        throw new MkctlError('Usage: mkctl run --file <path> [--duration <seconds>]', EXIT_CODES.USAGE);
+        throw new MkctlError('Usage: mkctl run --file <path> [--duration <seconds>] [--snapshot-interval <seconds>]', EXIT_CODES.USAGE);
       }
       const parsed = Number.parseInt(next, 10);
       if (Number.isNaN(parsed) || parsed <= 0) {
@@ -129,14 +131,25 @@ function parseRunArgs(args: string[]): RunArguments {
       }
       durationMs = parsed * 1000;
       i++;
+    } else if (token === '--snapshot-interval') {
+      const next = args[i + 1];
+      if (!next || next.startsWith('--')) {
+        throw new MkctlError('--snapshot-interval requires a number (seconds)', EXIT_CODES.USAGE);
+      }
+      const parsed = Number.parseInt(next, 10);
+      if (Number.isNaN(parsed) || parsed <= 0) {
+        throw new MkctlError('--snapshot-interval must be a positive integer (seconds)', EXIT_CODES.USAGE);
+      }
+      snapshotIntervalMs = parsed * 1000;
+      i++;
     }
   }
 
   if (!configPath) {
-    throw new MkctlError('Usage: mkctl run --file <path> [--duration <seconds>]', EXIT_CODES.USAGE);
+    throw new MkctlError('Usage: mkctl run --file <path> [--duration <seconds>] [--snapshot-interval <seconds>]', EXIT_CODES.USAGE);
   }
 
-  return { configPath, durationMs };
+  return { configPath, durationMs, snapshotIntervalMs };
 }
 
 async function waitForDurationOrSignal(durationMs: number): Promise<'timer' | 'signal'> {
@@ -375,7 +388,7 @@ async function writeRouterSnapshot(router: RoutingServer): Promise<void> {
 }
 
 async function handleRunCommand(args: string[]): Promise<number> {
-  const { configPath, durationMs } = parseRunArgs(args);
+  const { configPath, durationMs, snapshotIntervalMs } = parseRunArgs(args);
 
   const localNodeMode = process.env.MK_LOCAL_NODE === '1';
   if (localNodeMode) {
@@ -453,8 +466,24 @@ async function handleRunCommand(args: string[]): Promise<number> {
 
   console.log(`Topology running for ${durationMs / 1000} seconds...\n`);
 
+  let snapshotTimer: NodeJS.Timeout | undefined;
+  if (snapshotIntervalMs) {
+    console.log(`[mkctl] Mid-run snapshots enabled (every ${snapshotIntervalMs / 1000}s)`);
+    let snapshotCount = 0;
+    snapshotTimer = setInterval(() => {
+      snapshotCount++;
+      writeRouterSnapshot(router).catch((err) => {
+        logError(`Failed to write snapshot ${snapshotCount}: ${err instanceof Error ? err.message : String(err)}`);
+      });
+    }, snapshotIntervalMs);
+  }
+
   const outcome = await waitForDurationOrSignal(durationMs);
 
+  if (snapshotTimer) {
+    clearInterval(snapshotTimer);
+  }
+
   await writeRouterSnapshot(router).catch((err) => {
     logError(`Failed to write router snapshot: ${err instanceof Error ? err.message : String(err)}`);
   });
