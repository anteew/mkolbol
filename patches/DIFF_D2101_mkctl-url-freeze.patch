diff --git docs/devex/mkctl-cookbook.md docs/devex/mkctl-cookbook.md
index e9f6471..30bf532 100644
--- docs/devex/mkctl-cookbook.md
+++ docs/devex/mkctl-cookbook.md
@@ -1719,6 +1719,53 @@ cat reports/router-endpoints.json | jq 'length'
 
 View output from remote TCP or WebSocket pipes in real-time.
 
+### URL Format Contract (Frozen)
+
+The `mkctl connect` command uses a stable URL format for TCP and WebSocket connections:
+
+**TCP Format:**
+```
+tcp://HOST:PORT
+```
+
+**WebSocket Format:**
+```
+ws://HOST:PORT[/PATH]
+```
+
+**HOST:**
+- `localhost` - Local loopback
+- Hostname - Valid DNS hostname (RFC 1123)
+- IPv4 address - Four octets (0-255)
+
+**PORT:**
+- Integer between 1 and 65535
+- Required for both TCP and WebSocket
+
+**PATH:**
+- Optional for WebSocket
+- Must start with `/` if provided
+- Not allowed for TCP
+
+**Examples:**
+```bash
+# Valid TCP URLs
+tcp://localhost:30010
+tcp://192.168.1.100:30018
+tcp://example.com:8080
+
+# Valid WebSocket URLs
+ws://localhost:30015
+ws://localhost:30015/pipe
+ws://10.0.0.50:8080/ws
+```
+
+**Unsupported:**
+- HTTP/HTTPS protocols (use `ws://` instead)
+- IPv6 addresses (not supported in v1)
+- Port numbers outside 1-65535 range
+- TCP URLs with path components
+
 ### Connect to TCP Pipe
 
 Connect to a remote TCP pipe server and view the output:
diff --git scripts/mkctl.ts scripts/mkctl.ts
index 887ea28..15126e6 100644
--- scripts/mkctl.ts
+++ scripts/mkctl.ts
@@ -11,6 +11,14 @@ import { RoutingServer } from '../src/router/RoutingServer.js';
 import type { RoutingEndpoint } from '../src/types.js';
 import { TCPPipeClient } from '../src/pipes/adapters/TCPPipe.js';
 import { WebSocketPipeClient } from '../src/pipes/adapters/WebSocketPipe.js';
+import {
+  parseURL,
+  validateConnectOptions,
+  getConnectHelp,
+  URLParseError,
+  type ParsedURL as ConnectParsedURL,
+  type ConnectOptions,
+} from '../src/cli/connect.js';
 
 const EXIT_CODES = {
   SUCCESS: 0,
@@ -551,19 +559,7 @@ async function handleEndpointsCommand(args: string[]): Promise<void> {
   }
 }
 
-interface ConnectArguments {
-  url: string;
-  json: boolean;
-}
-
-interface ParsedURL {
-  protocol: 'tcp' | 'ws';
-  host: string;
-  port: number;
-  path?: string;
-}
-
-function parseConnectArgs(args: string[]): ConnectArguments {
+function parseConnectArgs(args: string[]): ConnectOptions {
   let url: string | undefined;
   let json = false;
 
@@ -578,51 +574,50 @@ function parseConnectArgs(args: string[]): ConnectArguments {
       i++;
     } else if (token === '--json') {
       json = true;
+    } else if (token === '--help' || token === '-h') {
+      console.log(getConnectHelp());
+      process.exit(EXIT_CODES.SUCCESS);
     }
   }
 
   if (!url) {
-    throw new MkctlError(
-      'Usage: mkctl connect --url <tcp://host:port | ws://host:port/path> [--json]',
-      EXIT_CODES.USAGE,
-    );
+    console.log(getConnectHelp());
+    throw new MkctlError('Missing required option: --url', EXIT_CODES.USAGE);
   }
 
   return { url, json };
 }
 
-function parseURL(url: string): ParsedURL {
-  const tcpMatch = url.match(/^tcp:\/\/([^:]+):(\d+)$/);
-  if (tcpMatch) {
-    const host = tcpMatch[1];
-    const port = Number.parseInt(tcpMatch[2], 10);
-    if (Number.isNaN(port) || port <= 0 || port > 65535) {
-      throw new MkctlError(`Invalid port in URL: ${url}`, EXIT_CODES.USAGE);
+async function handleConnectCommand(args: string[]): Promise<number> {
+  let options: ConnectOptions;
+  try {
+    options = parseConnectArgs(args);
+  } catch (err: unknown) {
+    if (err instanceof MkctlError) {
+      throw err;
     }
-    return { protocol: 'tcp', host, port };
+    throw new MkctlError(
+      err instanceof Error ? err.message : String(err),
+      EXIT_CODES.USAGE,
+    );
   }
 
-  const wsMatch = url.match(/^ws:\/\/([^:]+):(\d+)(\/.*)?$/);
-  if (wsMatch) {
-    const host = wsMatch[1];
-    const port = Number.parseInt(wsMatch[2], 10);
-    const path = wsMatch[3] || '/';
-    if (Number.isNaN(port) || port <= 0 || port > 65535) {
-      throw new MkctlError(`Invalid port in URL: ${url}`, EXIT_CODES.USAGE);
+  const { url, json } = options;
+
+  let parsed: ConnectParsedURL;
+  try {
+    validateConnectOptions(options);
+    parsed = parseURL(url);
+  } catch (err: unknown) {
+    if (err instanceof URLParseError) {
+      throw new MkctlError(err.message, EXIT_CODES.USAGE);
     }
-    return { protocol: 'ws', host, port, path };
+    throw new MkctlError(
+      err instanceof Error ? err.message : String(err),
+      EXIT_CODES.USAGE,
+    );
   }
 
-  throw new MkctlError(
-    `Invalid URL format: ${url}\nExpected: tcp://host:port or ws://host:port/path`,
-    EXIT_CODES.USAGE,
-  );
-}
-
-async function handleConnectCommand(args: string[]): Promise<number> {
-  const { url, json } = parseConnectArgs(args);
-  const parsed = parseURL(url);
-
   console.error(`[mkctl] Connecting to ${url}...`);
 
   let client: TCPPipeClient | WebSocketPipeClient;
diff --git tests/cli/mkctlConnect.spec.ts tests/cli/mkctlConnect.spec.ts
index b788361..97ac911 100644
--- tests/cli/mkctlConnect.spec.ts
+++ tests/cli/mkctlConnect.spec.ts
@@ -1,8 +1,186 @@
 import { describe, it, expect } from 'vitest';
 import { spawn, ChildProcess } from 'child_process';
 import { resolve } from 'path';
+import { parseURL, validateConnectOptions, URLParseError } from '../../src/cli/connect.js';
 
-describe('mkctl connect', () => {
+describe('connect module - parseURL', () => {
+  describe('TCP URLs', () => {
+    it('parses valid TCP URL with localhost', () => {
+      const result = parseURL('tcp://localhost:30010');
+      expect(result).toEqual({
+        protocol: 'tcp',
+        host: 'localhost',
+        port: 30010,
+      });
+    });
+
+    it('parses valid TCP URL with IPv4 address', () => {
+      const result = parseURL('tcp://192.168.1.100:30018');
+      expect(result).toEqual({
+        protocol: 'tcp',
+        host: '192.168.1.100',
+        port: 30018,
+      });
+    });
+
+    it('parses valid TCP URL with hostname', () => {
+      const result = parseURL('tcp://example.com:8080');
+      expect(result).toEqual({
+        protocol: 'tcp',
+        host: 'example.com',
+        port: 8080,
+      });
+    });
+
+    it('rejects TCP URL without port', () => {
+      expect(() => parseURL('tcp://localhost')).toThrow(URLParseError);
+      expect(() => parseURL('tcp://localhost')).toThrow('Invalid URL format');
+    });
+
+    it('rejects TCP URL with invalid port (zero)', () => {
+      expect(() => parseURL('tcp://localhost:0')).toThrow(URLParseError);
+      expect(() => parseURL('tcp://localhost:0')).toThrow('Port must be between 1 and 65535');
+    });
+
+    it('rejects TCP URL with invalid port (too high)', () => {
+      expect(() => parseURL('tcp://localhost:99999')).toThrow(URLParseError);
+      expect(() => parseURL('tcp://localhost:99999')).toThrow(
+        'Port must be between 1 and 65535',
+      );
+    });
+
+    it('rejects TCP URL with path', () => {
+      expect(() => parseURL('tcp://localhost:30010/path')).toThrow(URLParseError);
+      expect(() => parseURL('tcp://localhost:30010/path')).toThrow('Invalid URL format');
+    });
+  });
+
+  describe('WebSocket URLs', () => {
+    it('parses valid WS URL with localhost', () => {
+      const result = parseURL('ws://localhost:30015');
+      expect(result).toEqual({
+        protocol: 'ws',
+        host: 'localhost',
+        port: 30015,
+      });
+    });
+
+    it('parses valid WS URL with path', () => {
+      const result = parseURL('ws://localhost:30015/pipe');
+      expect(result).toEqual({
+        protocol: 'ws',
+        host: 'localhost',
+        port: 30015,
+        path: '/pipe',
+      });
+    });
+
+    it('parses valid WS URL with IPv4 address', () => {
+      const result = parseURL('ws://10.0.0.50:8080/ws');
+      expect(result).toEqual({
+        protocol: 'ws',
+        host: '10.0.0.50',
+        port: 8080,
+        path: '/ws',
+      });
+    });
+
+    it('rejects WS URL without port', () => {
+      expect(() => parseURL('ws://localhost')).toThrow(URLParseError);
+      expect(() => parseURL('ws://localhost')).toThrow('Invalid URL format');
+    });
+
+    it('rejects WS URL with invalid port', () => {
+      expect(() => parseURL('ws://localhost:70000')).toThrow(URLParseError);
+      expect(() => parseURL('ws://localhost:70000')).toThrow(
+        'Port must be between 1 and 65535',
+      );
+    });
+  });
+
+  describe('Invalid protocols', () => {
+    it('rejects HTTP URLs with helpful message', () => {
+      expect(() => parseURL('http://localhost:8080')).toThrow(URLParseError);
+      expect(() => parseURL('http://localhost:8080')).toThrow(
+        'HTTP/HTTPS not supported. Use ws:// for WebSocket or tcp:// for TCP',
+      );
+    });
+
+    it('rejects HTTPS URLs with helpful message', () => {
+      expect(() => parseURL('https://example.com:443')).toThrow(URLParseError);
+      expect(() => parseURL('https://example.com:443')).toThrow(
+        'HTTP/HTTPS not supported',
+      );
+    });
+
+    it('rejects unknown protocols', () => {
+      expect(() => parseURL('ftp://localhost:21')).toThrow(URLParseError);
+      expect(() => parseURL('ftp://localhost:21')).toThrow('Unsupported protocol: ftp');
+    });
+
+    it('rejects URLs without protocol', () => {
+      expect(() => parseURL('localhost:30010')).toThrow(URLParseError);
+      expect(() => parseURL('localhost:30010')).toThrow('Invalid URL format');
+    });
+  });
+
+  describe('Invalid hostnames', () => {
+    it('rejects empty hostname', () => {
+      expect(() => parseURL('tcp://:30010')).toThrow(URLParseError);
+      expect(() => parseURL('tcp://:30010')).toThrow('Invalid URL format');
+    });
+
+    it('rejects invalid IPv4 address (octet > 255)', () => {
+      expect(() => parseURL('tcp://192.168.256.1:30010')).toThrow(URLParseError);
+      expect(() => parseURL('tcp://192.168.256.1:30010')).toThrow('Invalid hostname');
+    });
+
+    it('rejects hostname starting with hyphen', () => {
+      expect(() => parseURL('tcp://-invalid.com:8080')).toThrow(URLParseError);
+      expect(() => parseURL('tcp://-invalid.com:8080')).toThrow('Invalid hostname');
+    });
+  });
+
+  describe('Edge cases', () => {
+    it('rejects null URL', () => {
+      expect(() => parseURL(null as any)).toThrow(URLParseError);
+      expect(() => parseURL(null as any)).toThrow('URL must be a non-empty string');
+    });
+
+    it('rejects undefined URL', () => {
+      expect(() => parseURL(undefined as any)).toThrow(URLParseError);
+      expect(() => parseURL(undefined as any)).toThrow('URL must be a non-empty string');
+    });
+
+    it('rejects empty string', () => {
+      expect(() => parseURL('')).toThrow(URLParseError);
+      expect(() => parseURL('')).toThrow('URL must be a non-empty string');
+    });
+  });
+});
+
+describe('connect module - validateConnectOptions', () => {
+  it('validates valid TCP options', () => {
+    expect(() => validateConnectOptions({ url: 'tcp://localhost:30010' })).not.toThrow();
+  });
+
+  it('validates valid WS options', () => {
+    expect(() =>
+      validateConnectOptions({ url: 'ws://localhost:30015/pipe' }),
+    ).not.toThrow();
+  });
+
+  it('rejects missing URL', () => {
+    expect(() => validateConnectOptions({ url: '' })).toThrow(URLParseError);
+    expect(() => validateConnectOptions({ url: '' })).toThrow('--url is required');
+  });
+
+  it('rejects invalid URL format', () => {
+    expect(() => validateConnectOptions({ url: 'invalid' })).toThrow(URLParseError);
+  });
+});
+
+describe('mkctl connect CLI', () => {
   const mkctlPath = resolve(__dirname, '../../scripts/mkctl.ts');
 
   function spawnMkctl(
@@ -109,7 +287,7 @@ describe('mkctl connect', () => {
     const outcome = await result;
 
     expect(outcome.code).toBe(EXIT_CODES.USAGE);
-    expect(outcome.stderr).toContain('Invalid port');
+    expect(outcome.stderr).toContain('Port must be between');
   });
 
   it('accepts --json flag', async () => {
