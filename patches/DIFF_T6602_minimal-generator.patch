diff --git a/src/digest/generator.ts b/src/digest/generator.ts
new file mode 100644
index 0000000..fa39cde
--- /dev/null
+++ b/src/digest/generator.ts
@@ -0,0 +1,101 @@
+import * as fs from 'node:fs';
+import * as readline from 'node:readline';
+import type { DigestConfig, DigestEvent, DigestOutput, DigestRule } from './types.js';
+
+export class DigestGenerator {
+  async generateDigest(eventsPath: string, config: DigestConfig): Promise<DigestOutput> {
+    const allEvents: DigestEvent[] = [];
+    
+    const fileStream = fs.createReadStream(eventsPath);
+    const rl = readline.createInterface({
+      input: fileStream,
+      crlfDelay: Infinity
+    });
+
+    for await (const line of rl) {
+      if (line.trim()) {
+        try {
+          const event = JSON.parse(line) as DigestEvent;
+          allEvents.push(event);
+        } catch {
+          continue;
+        }
+      }
+    }
+
+    const rules = config.rules || [];
+    const filteredEvents = this.applyRules(allEvents, rules);
+
+    return {
+      metadata: {
+        generated: Date.now(),
+        source: eventsPath,
+        eventCount: allEvents.length,
+        filteredCount: filteredEvents.length
+      },
+      events: filteredEvents,
+      summary: this.generateSummary(filteredEvents)
+    };
+  }
+
+  private applyRules(events: DigestEvent[], rules: DigestRule[]): DigestEvent[] {
+    return events.filter(event => {
+      for (const rule of rules) {
+        if (this.matchesRule(event, rule)) {
+          if (rule.type === 'exclude') {
+            return false;
+          }
+          if (rule.type === 'include') {
+            return true;
+          }
+        }
+      }
+      return true;
+    });
+  }
+
+  private matchesRule(event: DigestEvent, rule: DigestRule): boolean {
+    if (rule.eventType && event.evt !== rule.eventType) {
+      return false;
+    }
+    
+    if (rule.level && event.lvl !== rule.level) {
+      return false;
+    }
+    
+    if (rule.pattern) {
+      const pattern = rule.pattern instanceof RegExp 
+        ? rule.pattern 
+        : new RegExp(rule.pattern);
+      
+      const searchText = `${event.case} ${event.evt} ${event.phase || ''}`;
+      if (!pattern.test(searchText)) {
+        return false;
+      }
+    }
+    
+    return true;
+  }
+
+  private generateSummary(events: DigestEvent[]) {
+    const byLevel: Record<DigestEvent['lvl'], number> = {
+      debug: 0,
+      info: 0,
+      warn: 0,
+      error: 0
+    };
+    
+    const byEventType: Record<string, number> = {};
+
+    for (const event of events) {
+      byLevel[event.lvl]++;
+      byEventType[event.evt] = (byEventType[event.evt] || 0) + 1;
+    }
+
+    return {
+      totalEvents: events.length,
+      byLevel,
+      byEventType
+    };
+  }
+}
