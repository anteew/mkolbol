diff --git a/src/transforms/AnsiParser.ts b/src/transforms/AnsiParser.ts
index a3021d0..bf181e9 100644
--- a/src/transforms/AnsiParser.ts
+++ b/src/transforms/AnsiParser.ts
@@ -13,13 +13,38 @@ export interface AnsiParserEvent {
   data: any;
 }
 
+export interface AnsiParserOptions {
+  scrollbackLimit?: number;
+}
+
+export interface ScrollbackLine {
+  content: string;
+  style: AnsiParserState;
+  timestamp: number;
+}
+
+export interface TerminalSnapshot {
+  state: AnsiParserState;
+  scrollback: ScrollbackLine[];
+  timestamp: number;
+}
+
 export class AnsiParser {
   private state: AnsiParserState;
   private buffer: string = '';
   private events: AnsiParserEvent[] = [];
-
-  constructor() {
+  private charBatch: string = '';
+  private batchStartX: number = 0;
+  private batchStartY: number = 0;
+  private scrollback: ScrollbackLine[] = [];
+  private scrollbackLimit: number;
+  private currentLine: string = '';
+  private currentLineStyle: AnsiParserState;
+
+  constructor(options: AnsiParserOptions = {}) {
+    this.scrollbackLimit = options.scrollbackLimit ?? 1000;
     this.state = this.createInitialState();
+    this.currentLineStyle = { ...this.state };
   }
 
   private createInitialState(): AnsiParserState {
@@ -35,43 +60,77 @@ export class AnsiParser {
   }
 
   parse(input: string): AnsiParserEvent[] {
-    this.events = [];
+    this.events.length = 0;
     this.buffer = input;
+    this.charBatch = '';
     let i = 0;
 
     while (i < this.buffer.length) {
-      const char = this.buffer[i];
-      const charCode = char.charCodeAt(0);
+      const charCode = this.buffer.charCodeAt(i);
 
-      if (char === '\x1B' || char === '\u009B') {
+      if (charCode === 0x1B || charCode === 0x9B) {
+        this.flushCharBatch();
         const escapeLen = this.parseEscapeSequence(i);
         i += escapeLen;
-      } else if (char === '\n') {
+      } else if (charCode === 0x0A) {
+        this.flushCharBatch();
         this.handleLineFeed();
         i++;
-      } else if (char === '\r') {
+      } else if (charCode === 0x0D) {
+        this.flushCharBatch();
         this.handleCarriageReturn();
         i++;
-      } else if (char === '\t') {
+      } else if (charCode === 0x09) {
+        this.flushCharBatch();
         this.handleTab();
         i++;
-      } else if (char === '\b') {
+      } else if (charCode === 0x08) {
+        this.flushCharBatch();
         this.handleBackspace();
         i++;
-      } else if (charCode >= 32 && charCode <= 126) {
-        this.handlePrintable(char);
-        i++;
-      } else if (charCode >= 160) {
-        this.handlePrintable(char);
+      } else if ((charCode >= 32 && charCode <= 126) || charCode >= 160) {
+        if (this.charBatch.length === 0) {
+          this.batchStartX = this.state.cursorX;
+          this.batchStartY = this.state.cursorY;
+        }
+        this.charBatch += this.buffer[i];
+        this.state.cursorX++;
         i++;
       } else {
         i++;
       }
     }
 
+    this.flushCharBatch();
     return this.events;
   }
 
+  private flushCharBatch(): void {
+    if (this.charBatch.length === 0) return;
+
+    this.currentLine += this.charBatch;
+    this.currentLineStyle = { ...this.state };
+
+    this.events.push({
+      type: 'print',
+      data: { 
+        char: this.charBatch, 
+        x: this.batchStartX, 
+        y: this.batchStartY, 
+        style: { 
+          cursorX: this.state.cursorX,
+          cursorY: this.state.cursorY,
+          bold: this.state.bold,
+          underline: this.state.underline,
+          foregroundColor: this.state.foregroundColor,
+          backgroundColor: this.state.backgroundColor,
+          inverse: this.state.inverse,
+        } 
+      },
+    });
+    this.charBatch = '';
+  }
+
   private parseEscapeSequence(startIndex: number): number {
     const start = startIndex;
     let i = startIndex + 1;
@@ -95,17 +154,16 @@ export class AnsiParser {
 
   private parseCSI(startIndex: number): number {
     let i = startIndex;
-    let paramStr = '';
+    const paramStart = i;
 
     while (i < this.buffer.length) {
-      const char = this.buffer[i];
-      const charCode = char.charCodeAt(0);
+      const charCode = this.buffer.charCodeAt(i);
 
       if (charCode >= 0x30 && charCode <= 0x3F) {
-        paramStr += char;
         i++;
       } else if (charCode >= 0x40 && charCode <= 0x7E) {
-        this.executeCSI(paramStr, char);
+        const paramStr = this.buffer.slice(paramStart, i);
+        this.executeCSI(paramStr, this.buffer[i]);
         return i - startIndex + 3;
       } else {
         break;
@@ -130,7 +188,7 @@ export class AnsiParser {
   }
 
   private executeCSI(paramStr: string, command: string): void {
-    const params = paramStr.split(';').map(p => (p === '' ? 0 : parseInt(p, 10)));
+    const params = this.parseParams(paramStr);
 
     switch (command) {
       case 'm':
@@ -161,6 +219,29 @@ export class AnsiParser {
     }
   }
 
+  private parseParams(paramStr: string): number[] {
+    if (paramStr.length === 0) return [];
+    
+    const params: number[] = [];
+    let current = 0;
+    let hasDigits = false;
+
+    for (let i = 0; i < paramStr.length; i++) {
+      const charCode = paramStr.charCodeAt(i);
+      if (charCode >= 48 && charCode <= 57) {
+        current = current * 10 + (charCode - 48);
+        hasDigits = true;
+      } else if (charCode === 59) {
+        params.push(hasDigits ? current : 0);
+        current = 0;
+        hasDigits = false;
+      }
+    }
+    params.push(hasDigits ? current : 0);
+
+    return params;
+  }
+
   private handleSGR(params: number[]): void {
     if (params.length === 0) params = [0];
 
@@ -202,7 +283,15 @@ export class AnsiParser {
 
     this.events.push({
       type: 'style',
-      data: { ...this.state },
+      data: { 
+        cursorX: this.state.cursorX,
+        cursorY: this.state.cursorY,
+        bold: this.state.bold,
+        underline: this.state.underline,
+        foregroundColor: this.state.foregroundColor,
+        backgroundColor: this.state.backgroundColor,
+        inverse: this.state.inverse,
+      },
     });
   }
 
@@ -265,6 +354,7 @@ export class AnsiParser {
   }
 
   private handleLineFeed(): void {
+    this.pushLineToScrollback();
     this.state.cursorY++;
     this.events.push({
       type: 'print',
@@ -272,6 +362,22 @@ export class AnsiParser {
     });
   }
 
+  private pushLineToScrollback(): void {
+    if (this.currentLine.length > 0) {
+      this.scrollback.push({
+        content: this.currentLine,
+        style: { ...this.currentLineStyle },
+        timestamp: Date.now(),
+      });
+      
+      if (this.scrollback.length > this.scrollbackLimit) {
+        this.scrollback.shift();
+      }
+      
+      this.currentLine = '';
+    }
+  }
+
   private handleCarriageReturn(): void {
     this.state.cursorX = 0;
     this.events.push({
@@ -297,21 +403,45 @@ export class AnsiParser {
     });
   }
 
-  private handlePrintable(char: string): void {
-    this.events.push({
-      type: 'print',
-      data: { char, x: this.state.cursorX, y: this.state.cursorY, style: { ...this.state } },
-    });
-    this.state.cursorX++;
+  getState(): AnsiParserState {
+    return { 
+      cursorX: this.state.cursorX,
+      cursorY: this.state.cursorY,
+      bold: this.state.bold,
+      underline: this.state.underline,
+      foregroundColor: this.state.foregroundColor,
+      backgroundColor: this.state.backgroundColor,
+      inverse: this.state.inverse,
+    };
   }
 
-  getState(): AnsiParserState {
-    return { ...this.state };
+  getScrollback(): ScrollbackLine[] {
+    return [...this.scrollback];
+  }
+
+  snapshot(): TerminalSnapshot {
+    return {
+      state: { ...this.state },
+      scrollback: [...this.scrollback],
+      timestamp: Date.now(),
+    };
+  }
+
+  exportJSON(): string {
+    return JSON.stringify(this.snapshot(), null, 2);
+  }
+
+  exportPlainText(): string {
+    const lines = this.scrollback.map(line => line.content);
+    return lines.join('\n');
   }
 
   reset(): void {
     this.state = this.createInitialState();
     this.buffer = '';
     this.events = [];
+    this.scrollback = [];
+    this.currentLine = '';
+    this.currentLineStyle = { ...this.state };
   }
 }
