diff --git a/src/mk/logs.ts b/src/mk/logs.ts
new file mode 100644
index 0000000..9d20ca9
--- /dev/null
+++ b/src/mk/logs.ts
@@ -0,0 +1,255 @@
+import * as fs from 'fs';
+import * as path from 'path';
+import { createInterface } from 'readline';
+
+export type LogLevel = 'error' | 'warn' | 'info' | 'debug';
+
+export interface LogsOptions {
+  module?: string;
+  level?: LogLevel;
+  json?: boolean;
+  follow?: boolean;
+  lines?: number;
+}
+
+export interface LogEntry {
+  timestamp: string;
+  level: LogLevel;
+  module: string;
+  event: string;
+  payload?: unknown;
+}
+
+const LEVEL_VALUES: Record<LogLevel, number> = {
+  error: 0,
+  warn: 1,
+  info: 2,
+  debug: 3,
+};
+
+function parseDebugLog(line: string): LogEntry | null {
+  try {
+    const timestampMatch = line.match(/^\[([\d-T:.Z]+)\]/);
+    const levelMatch = line.match(/\[([A-Z]+)\]/);
+    const moduleMatch = line.match(/\[([a-z-]+)\]/);
+    const eventMatch = line.match(/\]\s+([^:]+)(?::(.*))?$/);
+
+    if (timestampMatch && levelMatch && moduleMatch) {
+      const level = levelMatch[1].toLowerCase() as LogLevel;
+      const event = eventMatch ? eventMatch[1].trim() : 'unknown';
+      const payloadStr = eventMatch && eventMatch[2] ? eventMatch[2].trim() : undefined;
+      let payload: unknown = undefined;
+
+      if (payloadStr) {
+        try {
+          payload = JSON.parse(payloadStr);
+        } catch {
+          payload = payloadStr;
+        }
+      }
+
+      return {
+        timestamp: timestampMatch[1],
+        level,
+        module: moduleMatch[1],
+        event,
+        payload,
+      };
+    }
+  } catch (e) {
+    return null;
+  }
+  return null;
+}
+
+function parseJsonlLog(line: string): LogEntry | null {
+  try {
+    const data = JSON.parse(line);
+    
+    if (data.evt && data.evt.startsWith('debug.')) {
+      const parts = data.evt.split('.');
+      const module = parts[1] || 'unknown';
+      const event = parts.slice(2).join('.') || 'unknown';
+      
+      return {
+        timestamp: data.ts ? new Date(data.ts).toISOString() : new Date().toISOString(),
+        level: (data.lvl as LogLevel) || 'info',
+        module,
+        event,
+        payload: data.payload,
+      };
+    }
+  } catch (e) {
+    return null;
+  }
+  return null;
+}
+
+function shouldIncludeLog(entry: LogEntry, options: LogsOptions): boolean {
+  if (options.module && entry.module !== options.module) {
+    return false;
+  }
+
+  if (options.level) {
+    const entryLevel = LEVEL_VALUES[entry.level];
+    const filterLevel = LEVEL_VALUES[options.level];
+    if (entryLevel > filterLevel) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+function formatLogHuman(entry: LogEntry): string {
+  const timestamp = new Date(entry.timestamp).toISOString();
+  const levelStr = entry.level.toUpperCase().padEnd(5);
+  const moduleStr = entry.module.padEnd(15);
+  const payload = entry.payload ? ` ${JSON.stringify(entry.payload)}` : '';
+  return `[${timestamp}] ${levelStr} [${moduleStr}] ${entry.event}${payload}`;
+}
+
+function formatLogJson(entry: LogEntry): string {
+  return JSON.stringify(entry);
+}
+
+async function tailDebugLogs(options: LogsOptions): Promise<void> {
+  const debugLog = process.env.DEBUG === '1' || process.env.MK_DEBUG_MODULES;
+  
+  if (!debugLog) {
+    console.error('Debug logging is not enabled. Set DEBUG=1 or MK_DEBUG_MODULES to enable.');
+    return;
+  }
+
+  console.error('Reading from console output (DEBUG mode)...');
+  console.error('This command works best with pre-captured logs or JSONL files.');
+  console.error('Use: DEBUG=1 mk run <topology> 2>&1 | mk logs [options]');
+}
+
+async function tailJsonlLogs(logPath: string, options: LogsOptions): Promise<void> {
+  if (!fs.existsSync(logPath)) {
+    throw new Error(`Log file not found: ${logPath}`);
+  }
+
+  const stream = fs.createReadStream(logPath);
+  const rl = createInterface({
+    input: stream,
+    crlfDelay: Infinity,
+  });
+
+  const entries: LogEntry[] = [];
+
+  for await (const line of rl) {
+    const entry = parseJsonlLog(line);
+    if (entry && shouldIncludeLog(entry, options)) {
+      entries.push(entry);
+    }
+  }
+
+  const linesToShow = options.lines || 50;
+  const toDisplay = entries.slice(-linesToShow);
+
+  for (const entry of toDisplay) {
+    const formatted = options.json ? formatLogJson(entry) : formatLogHuman(entry);
+    console.log(formatted);
+  }
+}
+
+async function followJsonlLogs(logPath: string, options: LogsOptions): Promise<void> {
+  if (!fs.existsSync(logPath)) {
+    throw new Error(`Log file not found: ${logPath}`);
+  }
+
+  let position = 0;
+  const fileStats = fs.statSync(logPath);
+  position = Math.max(0, fileStats.size);
+
+  console.error(`Following logs from: ${logPath}`);
+  console.error('Press Ctrl+C to stop...\n');
+
+  const checkForChanges = () => {
+    const currentStats = fs.statSync(logPath);
+    if (currentStats.size > position) {
+      const stream = fs.createReadStream(logPath, {
+        start: position,
+        encoding: 'utf8',
+      });
+
+      let buffer = '';
+      stream.on('data', (chunk) => {
+        buffer += chunk;
+        const lines = buffer.split('\n');
+        buffer = lines.pop() || '';
+
+        for (const line of lines) {
+          if (line.trim()) {
+            const entry = parseJsonlLog(line);
+            if (entry && shouldIncludeLog(entry, options)) {
+              const formatted = options.json ? formatLogJson(entry) : formatLogHuman(entry);
+              console.log(formatted);
+            }
+          }
+        }
+      });
+
+      stream.on('end', () => {
+        position = currentStats.size;
+      });
+    }
+  };
+
+  const interval = setInterval(checkForChanges, 500);
+
+  process.on('SIGINT', () => {
+    clearInterval(interval);
+    console.error('\nStopped following logs.');
+    process.exit(0);
+  });
+
+  process.on('SIGTERM', () => {
+    clearInterval(interval);
+    process.exit(0);
+  });
+}
+
+export async function tailLogs(options: LogsOptions): Promise<void> {
+  const reportsDir = path.join(process.cwd(), 'reports');
+  
+  if (!fs.existsSync(reportsDir)) {
+    await tailDebugLogs(options);
+    return;
+  }
+
+  const suites = fs.readdirSync(reportsDir).filter(f => {
+    const stat = fs.statSync(path.join(reportsDir, f));
+    return stat.isDirectory();
+  });
+
+  if (suites.length === 0) {
+    await tailDebugLogs(options);
+    return;
+  }
+
+  const suite = suites[0];
+  const suiteDir = path.join(reportsDir, suite);
+  const logFiles = fs.readdirSync(suiteDir).filter(f => f.endsWith('.jsonl'));
+
+  if (logFiles.length === 0) {
+    await tailDebugLogs(options);
+    return;
+  }
+
+  const latestLog = logFiles
+    .map(f => ({
+      name: f,
+      path: path.join(suiteDir, f),
+      mtime: fs.statSync(path.join(suiteDir, f)).mtime,
+    }))
+    .sort((a, b) => b.mtime.getTime() - a.mtime.getTime())[0];
+
+  if (options.follow) {
+    await followJsonlLogs(latestLog.path, options);
+  } else {
+    await tailJsonlLogs(latestLog.path, options);
+  }
+}
diff --git a/tests/cli/mkLogs.spec.ts b/tests/cli/mkLogs.spec.ts
new file mode 100644
index 0000000..74c17a3
--- /dev/null
+++ b/tests/cli/mkLogs.spec.ts
@@ -0,0 +1,287 @@
+import { describe, it, expect, beforeAll, afterAll } from 'vitest';
+import { spawnSync, spawn, ChildProcess } from 'node:child_process';
+import { join } from 'node:path';
+import { writeFileSync, unlinkSync, mkdirSync, existsSync, rmSync } from 'node:fs';
+import { tmpdir } from 'node:os';
+
+describe('mk logs command', () => {
+  const mkPath = join(process.cwd(), 'dist', 'scripts', 'mk.js');
+  const testDir = join(tmpdir(), 'mk-logs-test');
+  const reportsDir = join(testDir, 'reports', 'test-suite');
+  const testLogPath = join(reportsDir, 'test.case.jsonl');
+
+  beforeAll(() => {
+    if (existsSync(testDir)) {
+      rmSync(testDir, { recursive: true, force: true });
+    }
+    mkdirSync(reportsDir, { recursive: true });
+
+    const logEntries = [
+      {
+        ts: Date.now() - 5000,
+        lvl: 'error',
+        case: 'test.case',
+        evt: 'debug.kernel.pipe.error',
+        payload: { pipeId: 'pipe-1', error: 'connection failed' },
+      },
+      {
+        ts: Date.now() - 4000,
+        lvl: 'warn',
+        case: 'test.case',
+        evt: 'debug.router.sweep.stale',
+        payload: { serverId: 'server-1', ttl: 5000 },
+      },
+      {
+        ts: Date.now() - 3000,
+        lvl: 'info',
+        case: 'test.case',
+        evt: 'debug.kernel.pipe.connect',
+        payload: { fromId: 'node-1', toId: 'node-2' },
+      },
+      {
+        ts: Date.now() - 2000,
+        lvl: 'debug',
+        case: 'test.case',
+        evt: 'debug.executor.start',
+        payload: { nodeCount: 3 },
+      },
+      {
+        ts: Date.now() - 1000,
+        lvl: 'info',
+        case: 'test.case',
+        evt: 'debug.filesystem-sink.write',
+        payload: { path: '/tmp/output.txt', bytes: 1024 },
+      },
+    ];
+
+    const logContent = logEntries.map((e) => JSON.stringify(e)).join('\n') + '\n';
+    writeFileSync(testLogPath, logContent);
+  });
+
+  afterAll(() => {
+    try {
+      rmSync(testDir, { recursive: true, force: true });
+    } catch (e) {
+      // ignore
+    }
+  });
+
+  it('shows help when --help flag is used', () => {
+    const r = spawnSync('node', [mkPath, 'logs', '--help'], { encoding: 'utf8' });
+
+    expect(r.status).toBe(0);
+    expect(r.stdout).toContain('Tail module logs with filtering');
+    expect(r.stdout).toContain('Usage: mk logs');
+  });
+
+  it('tails logs in human-readable format by default', () => {
+    const r = spawnSync('node', [mkPath, 'logs'], {
+      encoding: 'utf8',
+      cwd: testDir,
+    });
+
+    expect(r.status).toBe(0);
+    expect(r.stdout).toContain('kernel');
+    expect(r.stdout).toContain('router');
+    expect(r.stdout).toContain('executor');
+    expect(r.stdout).toContain('filesystem-sink');
+  });
+
+  it('filters logs by module name', () => {
+    const r = spawnSync('node', [mkPath, 'logs', '--module', 'kernel'], {
+      encoding: 'utf8',
+      cwd: testDir,
+    });
+
+    expect(r.status).toBe(0);
+    expect(r.stdout).toContain('kernel');
+    expect(r.stdout).not.toContain('router');
+    expect(r.stdout).not.toContain('executor');
+  });
+
+  it('filters logs by level (error)', () => {
+    const r = spawnSync('node', [mkPath, 'logs', '--level', 'error'], {
+      encoding: 'utf8',
+      cwd: testDir,
+    });
+
+    expect(r.status).toBe(0);
+    expect(r.stdout).toContain('ERROR');
+    expect(r.stdout).not.toContain('WARN');
+    expect(r.stdout).not.toContain('INFO');
+    expect(r.stdout).not.toContain('DEBUG');
+  });
+
+  it('filters logs by level (warn) includes error and warn', () => {
+    const r = spawnSync('node', [mkPath, 'logs', '--level', 'warn'], {
+      encoding: 'utf8',
+      cwd: testDir,
+    });
+
+    expect(r.status).toBe(0);
+    expect(r.stdout).toContain('ERROR');
+    expect(r.stdout).toContain('WARN');
+    expect(r.stdout).not.toContain('INFO');
+    expect(r.stdout).not.toContain('DEBUG');
+  });
+
+  it('filters logs by level (info) includes error, warn, and info', () => {
+    const r = spawnSync('node', [mkPath, 'logs', '--level', 'info'], {
+      encoding: 'utf8',
+      cwd: testDir,
+    });
+
+    expect(r.status).toBe(0);
+    expect(r.stdout).toContain('ERROR');
+    expect(r.stdout).toContain('WARN');
+    expect(r.stdout).toContain('INFO');
+    expect(r.stdout).not.toContain('DEBUG');
+  });
+
+  it('outputs logs in JSON format with --json flag', () => {
+    const r = spawnSync('node', [mkPath, 'logs', '--json'], {
+      encoding: 'utf8',
+      cwd: testDir,
+    });
+
+    expect(r.status).toBe(0);
+
+    const lines = r.stdout.trim().split('\n');
+    expect(lines.length).toBeGreaterThan(0);
+
+    const firstLog = JSON.parse(lines[0]);
+    expect(firstLog).toHaveProperty('timestamp');
+    expect(firstLog).toHaveProperty('level');
+    expect(firstLog).toHaveProperty('module');
+    expect(firstLog).toHaveProperty('event');
+  });
+
+  it('combines multiple filters (module and level)', () => {
+    const r = spawnSync('node', [mkPath, 'logs', '--module', 'kernel', '--level', 'error'], {
+      encoding: 'utf8',
+      cwd: testDir,
+    });
+
+    expect(r.status).toBe(0);
+    expect(r.stdout).toContain('kernel');
+    expect(r.stdout).toContain('ERROR');
+    expect(r.stdout).not.toContain('router');
+    expect(r.stdout).not.toContain('INFO');
+  });
+
+  it('limits output lines with --lines flag', () => {
+    const r = spawnSync('node', [mkPath, 'logs', '--lines', '2'], {
+      encoding: 'utf8',
+      cwd: testDir,
+    });
+
+    expect(r.status).toBe(0);
+    const lines = r.stdout.trim().split('\n').filter(l => l.length > 0);
+    expect(lines.length).toBeLessThanOrEqual(2);
+  });
+
+  it('shows error for invalid level', () => {
+    const r = spawnSync('node', [mkPath, 'logs', '--level', 'invalid'], {
+      encoding: 'utf8',
+      cwd: testDir,
+    });
+
+    expect(r.status).toBe(64);
+    expect(r.stderr).toContain('Invalid level');
+  });
+
+  it('shows error for invalid --lines value', () => {
+    const r = spawnSync('node', [mkPath, 'logs', '--lines', 'abc'], {
+      encoding: 'utf8',
+      cwd: testDir,
+    });
+
+    expect(r.status).toBe(64);
+    expect(r.stderr).toContain('Invalid --lines value');
+  });
+
+  it('accepts -f as short form of --follow', () => {
+    const proc = spawn('node', [mkPath, 'logs', '-f'], {
+      cwd: testDir,
+      stdio: 'pipe',
+    });
+
+    let stderr = '';
+    proc.stderr?.on('data', (chunk) => {
+      stderr += chunk.toString();
+    });
+
+    setTimeout(() => {
+      proc.kill('SIGTERM');
+    }, 500);
+
+    return new Promise<void>((resolve) => {
+      proc.on('exit', () => {
+        expect(stderr).toContain('Following logs from');
+        resolve();
+      });
+    });
+  });
+
+  it('shows human-readable timestamps in output', () => {
+    const r = spawnSync('node', [mkPath, 'logs'], {
+      encoding: 'utf8',
+      cwd: testDir,
+    });
+
+    expect(r.status).toBe(0);
+    expect(r.stdout).toMatch(/\[\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z\]/);
+  });
+
+  it('includes payload in human-readable output', () => {
+    const r = spawnSync('node', [mkPath, 'logs', '--module', 'kernel', '--level', 'error'], {
+      encoding: 'utf8',
+      cwd: testDir,
+    });
+
+    expect(r.status).toBe(0);
+    expect(r.stdout).toContain('pipeId');
+    expect(r.stdout).toContain('pipe-1');
+    expect(r.stdout).toContain('connection failed');
+  });
+
+  it('handles empty reports directory gracefully', () => {
+    const emptyDir = join(tmpdir(), 'mk-logs-empty');
+    if (existsSync(emptyDir)) {
+      rmSync(emptyDir, { recursive: true, force: true });
+    }
+    mkdirSync(emptyDir, { recursive: true });
+
+    const r = spawnSync('node', [mkPath, 'logs'], {
+      encoding: 'utf8',
+      cwd: emptyDir,
+    });
+
+    expect(r.status).toBe(0);
+    expect(r.stderr).toContain('Debug logging is not enabled');
+
+    rmSync(emptyDir, { recursive: true, force: true });
+  });
+
+  it('displays module names padded in human format', () => {
+    const r = spawnSync('node', [mkPath, 'logs'], {
+      encoding: 'utf8',
+      cwd: testDir,
+    });
+
+    expect(r.status).toBe(0);
+    expect(r.stdout).toMatch(/\[kernel\s+\]/);
+    expect(r.stdout).toMatch(/\[router\s+\]/);
+  });
+
+  it('shows event names after module', () => {
+    const r = spawnSync('node', [mkPath, 'logs', '--module', 'kernel'], {
+      encoding: 'utf8',
+      cwd: testDir,
+    });
+
+    expect(r.status).toBe(0);
+    expect(r.stdout).toContain('pipe.error');
+    expect(r.stdout).toContain('pipe.connect');
+  });
+});
diff --git a/scripts/mk.ts b/scripts/mk.ts
index 2cf317c..b0565f2 100644
--- a/scripts/mk.ts
+++ b/scripts/mk.ts
@@ -33,6 +33,97 @@ const commands: Command[] = [
       return runHandler(args);
     },
   },
+  {
+    name: 'dev',
+    description: 'Run topology with hot-reload for in-proc modules',
+    usage: 'mk dev <config> [--verbose]',
+    handler: async (args: string[]) => {
+      if (args.length === 0) {
+        console.error('Error: Missing topology config file');
+        console.error('Usage: mk dev <config> [--verbose]');
+        return EXIT_USAGE;
+      }
+
+      const configPath = args[0];
+      const verbose = args.includes('--verbose');
+
+      try {
+        const { loadConfig } = await import('../src/config/loader.js');
+        const { Kernel } = await import('../src/kernel/Kernel.js');
+        const { Hostess } = await import('../src/hostess/Hostess.js');
+        const { StateManager } = await import('../src/state/StateManager.js');
+        const { Executor } = await import('../src/executor/Executor.js');
+        const { watchModules } = await import('../src/mk/dev.js');
+        
+        // Load topology
+        const topology = loadConfig(configPath);
+        
+        console.log('[mk dev] Starting topology with hot-reload...');
+        
+        // Initialize system
+        const kernel = new Kernel();
+        const hostess = new Hostess();
+        const stateManager = new StateManager(kernel);
+        const executor = new Executor(kernel, hostess, stateManager);
+        
+        // Register modules
+        const modules = [
+          { name: 'TimerSource', path: '../src/modules/timer.js' },
+          { name: 'UppercaseTransform', path: '../src/modules/uppercase.js' },
+          { name: 'ConsoleSink', path: '../src/modules/consoleSink.js' },
+          { name: 'FilesystemSink', path: '../src/modules/filesystem-sink.js' },
+          { name: 'PipeMeterTransform', path: '../src/transforms/pipeMeter.js' },
+          { name: 'RateLimiterTransform', path: '../src/transforms/rateLimiter.js' },
+          { name: 'TeeTransform', path: '../src/transforms/tee.js' },
+        ];
+        
+        for (const mod of modules) {
+          try {
+            const modulePath = new URL(mod.path, import.meta.url).pathname;
+            const moduleExport = await import(modulePath);
+            executor.registerModule(mod.name, moduleExport.default || moduleExport[mod.name]);
+          } catch (err) {
+            // Module might not exist, skip
+          }
+        }
+        
+        // Load and start executor
+        executor.load(topology);
+        await executor.up();
+        
+        // Start file watchers
+        const watcher = watchModules(executor, topology, {
+          verbose,
+          onReload: (nodeId) => {
+            console.log(`[mk dev] Node ${nodeId} hot-reloaded`);
+          }
+        });
+        
+        console.log('[mk dev] System running. Press Ctrl+C to stop.');
+        
+        // Handle graceful shutdown
+        const shutdown = async () => {
+          console.log('\n[mk dev] Shutting down...');
+          watcher.stop();
+          await executor.down();
+          process.exit(EXIT_SUCCESS);
+        };
+        
+        process.on('SIGINT', shutdown);
+        process.on('SIGTERM', shutdown);
+        
+        // Keep process alive
+        await new Promise<void>((resolve) => {
+          // Never resolves - keeps process running until signal
+        });
+        
+        return EXIT_SUCCESS;
+      } catch (error) {
+        console.error(`Error: ${error instanceof Error ? error.message : String(error)}`);
+        return EXIT_ERROR;
+      }
+    },
+  },
   {
     name: 'doctor',
     description: 'Diagnose system and dependency issues',
@@ -153,6 +244,55 @@ const commands: Command[] = [
       }
     },
   },
+  {
+    name: 'logs',
+    description: 'Tail module logs with filtering',
+    usage: 'mk logs [--module <name>] [--level <error|warn|info|debug>] [--json] [--follow] [--lines <n>]',
+    handler: async (args: string[]) => {
+      const { tailLogs } = await import('../src/mk/logs.js');
+      
+      const options: {
+        module?: string;
+        level?: 'error' | 'warn' | 'info' | 'debug';
+        json?: boolean;
+        follow?: boolean;
+        lines?: number;
+      } = {};
+      
+      for (let i = 0; i < args.length; i++) {
+        const arg = args[i];
+        if (arg === '--module' && i + 1 < args.length) {
+          options.module = args[++i];
+        } else if (arg === '--level' && i + 1 < args.length) {
+          const level = args[++i];
+          if (level === 'error' || level === 'warn' || level === 'info' || level === 'debug') {
+            options.level = level;
+          } else {
+            console.error(`Invalid level: ${level}. Use: error, warn, info, or debug`);
+            return EXIT_USAGE;
+          }
+        } else if (arg === '--json') {
+          options.json = true;
+        } else if (arg === '--follow' || arg === '-f') {
+          options.follow = true;
+        } else if (arg === '--lines' && i + 1 < args.length) {
+          options.lines = parseInt(args[++i], 10);
+          if (isNaN(options.lines) || options.lines <= 0) {
+            console.error('Invalid --lines value. Must be a positive number.');
+            return EXIT_USAGE;
+          }
+        }
+      }
+      
+      try {
+        await tailLogs(options);
+        return EXIT_SUCCESS;
+      } catch (error) {
+        console.error(`Error: ${error instanceof Error ? error.message : String(error)}`);
+        return EXIT_ERROR;
+      }
+    },
+  },
 ];
 
 function printMainHelp() {
