diff --git a/src/transport/unix/UnixControlAdapter.ts b/src/transport/unix/UnixControlAdapter.ts
new file mode 100644
index 0000000..f45aab9
--- /dev/null
+++ b/src/transport/unix/UnixControlAdapter.ts
@@ -0,0 +1,157 @@
+// UnixControlAdapter: control-plane pub/sub + heartbeats over Unix sockets
+import { Socket, Server, createServer } from 'node:net';
+import { mkdirSync } from 'node:fs';
+import { dirname } from 'node:path';
+
+interface ProcessControlAdapter {
+  publish(topic: string, data: unknown): void;
+  subscribe(topic: string, handler: (data: unknown) => void): () => void;
+}
+
+interface ControlMessage {
+  type: 'control';
+  topic: string;
+  data: unknown;
+}
+
+export class UnixControlAdapter implements ProcessControlAdapter {
+  private handlers = new Map<string, Set<(data: unknown) => void>>();
+  private socket?: Socket;
+  private server?: Server;
+  private heartbeatInterval?: NodeJS.Timeout;
+  private readonly socketPath: string;
+  private readonly isServer: boolean;
+  private closed = false;
+
+  constructor(socketPath: string, isServer: boolean) {
+    this.socketPath = socketPath;
+    this.isServer = isServer;
+
+    if (isServer) {
+      this.startServer();
+    } else {
+      this.connectClient();
+    }
+
+    this.startHeartbeat();
+  }
+
+  private startServer(): void {
+    mkdirSync(dirname(this.socketPath), { recursive: true });
+    this.server = createServer((socket) => {
+      this.socket = socket;
+      this.setupSocket(socket);
+    });
+    this.server.listen(this.socketPath);
+  }
+
+  private connectClient(): void {
+    this.socket = new Socket();
+    this.socket.connect(this.socketPath);
+    this.setupSocket(this.socket);
+  }
+
+  private setupSocket(socket: Socket): void {
+    let buffer = '';
+
+    socket.on('data', (chunk) => {
+      buffer += chunk.toString();
+      let newlineIndex: number;
+
+      while ((newlineIndex = buffer.indexOf('\n')) !== -1) {
+        const line = buffer.slice(0, newlineIndex);
+        buffer = buffer.slice(newlineIndex + 1);
+
+        try {
+          const msg = JSON.parse(line) as ControlMessage;
+          if (msg?.type === 'control' && msg?.topic) {
+            this.handleIncoming(msg.topic, msg.data);
+          }
+        } catch {
+          // Ignore malformed messages
+        }
+      }
+    });
+
+    socket.on('error', () => {
+      // Suppress errors during shutdown
+    });
+  }
+
+  private startHeartbeat(): void {
+    this.heartbeatInterval = setInterval(() => {
+      if (!this.closed) {
+        this.publish('control.heartbeat', { ts: Date.now() });
+      }
+    }, 1000);
+  }
+
+  publish(topic: string, data: unknown): void {
+    if (this.closed || !this.socket || this.socket.destroyed) {
+      return;
+    }
+
+    const msg: ControlMessage = { type: 'control', topic, data };
+    const payload = JSON.stringify(msg) + '\n';
+
+    try {
+      this.socket.write(payload);
+    } catch {
+      // Ignore write errors
+    }
+  }
+
+  subscribe(topic: string, handler: (data: unknown) => void): () => void {
+    if (!this.handlers.has(topic)) {
+      this.handlers.set(topic, new Set());
+    }
+    this.handlers.get(topic)!.add(handler);
+    return () => {
+      this.handlers.get(topic)?.delete(handler);
+    };
+  }
+
+  private handleIncoming(topic: string, data: unknown): void {
+    const handlers = this.handlers.get(topic);
+    if (handlers) {
+      for (const handler of handlers) {
+        handler(data);
+      }
+    }
+  }
+
+  shutdown(): void {
+    if (this.closed) {
+      return;
+    }
+
+    this.publish('control.shutdown', { ts: Date.now() });
+
+    setTimeout(() => {
+      this.close();
+    }, 100);
+  }
+
+  close(): void {
+    if (this.closed) {
+      return;
+    }
+
+    this.closed = true;
+
+    if (this.heartbeatInterval) {
+      clearInterval(this.heartbeatInterval);
+      this.heartbeatInterval = undefined;
+    }
+
+    if (this.socket && !this.socket.destroyed) {
+      this.socket.end();
+      this.socket.destroy();
+    }
+
+    if (this.server) {
+      this.server.close();
+      this.server = undefined;
+    }
+  }
+}
diff --git a/src/transport/unix/UnixPipeAdapter.ts b/src/transport/unix/UnixPipeAdapter.ts
new file mode 100644
index 0000000..86cf5dc
--- /dev/null
+++ b/src/transport/unix/UnixPipeAdapter.ts
@@ -0,0 +1,160 @@
+import { Duplex } from 'stream';
+import { Socket, Server, createServer, createConnection } from 'node:net';
+import type { Pipe, StreamOptions } from '../../types/stream.js';
+
+interface ProcessPipeAdapter {
+  createDuplex(options?: StreamOptions): Pipe;
+  listen(): Promise<void>;
+  connect(): Promise<void>;
+  close(): void;
+}
+
+interface UnixPipeAdapterOptions extends StreamOptions {
+  socket: Socket;
+}
+
+class UnixPipeAdapterDuplex extends Duplex {
+  private socket: Socket;
+  private isClosing: boolean = false;
+
+  constructor(options: UnixPipeAdapterOptions) {
+    const { socket, ...streamOptions } = options;
+    super(streamOptions);
+    this.socket = socket;
+
+    this.socket.on('data', (data: Buffer) => {
+      if (!this.push(data)) {
+        this.socket.pause();
+      }
+    });
+
+    this.socket.on('end', () => {
+      this.push(null);
+    });
+
+    this.socket.on('error', (err: Error) => {
+      this.destroy(err);
+    });
+
+    this.socket.on('close', () => {
+      if (!this.isClosing) {
+        this.destroy();
+      }
+    });
+  }
+
+  _read(size: number): void {
+    this.socket.resume();
+  }
+
+  _write(
+    chunk: any,
+    encoding: BufferEncoding,
+    callback: (error?: Error | null) => void
+  ): void {
+    const canContinue = this.socket.write(chunk, encoding, (err) => {
+      if (err) {
+        callback(err);
+      }
+    });
+
+    if (canContinue) {
+      callback();
+    } else {
+      this.socket.once('drain', () => {
+        callback();
+      });
+    }
+  }
+
+  _final(callback: (error?: Error | null) => void): void {
+    this.socket.end(() => {
+      callback();
+    });
+  }
+
+  _destroy(
+    error: Error | null,
+    callback: (error?: Error | null) => void
+  ): void {
+    this.isClosing = true;
+    if (!this.socket.destroyed) {
+      this.socket.destroy();
+    }
+    callback(error);
+  }
+}
+
+export class UnixPipeAdapter implements ProcessPipeAdapter {
+  private socketPath: string;
+  private server?: Server;
+  private socket?: Socket;
+  private isListening: boolean = false;
+  private isConnected: boolean = false;
+
+  constructor(socketPath: string) {
+    this.socketPath = socketPath;
+  }
+
+  async listen(): Promise<void> {
+    if (this.isListening) {
+      return;
+    }
+
+    return new Promise((resolve, reject) => {
+      this.server = createServer((socket) => {
+        this.socket = socket;
+      });
+
+      this.server.on('error', (err) => {
+        reject(err);
+      });
+
+      this.server.listen(this.socketPath, () => {
+        this.isListening = true;
+        resolve();
+      });
+    });
+  }
+
+  async connect(): Promise<void> {
+    if (this.isConnected) {
+      return;
+    }
+
+    return new Promise((resolve, reject) => {
+      const socket = createConnection(this.socketPath);
+
+      socket.on('connect', () => {
+        this.socket = socket;
+        this.isConnected = true;
+        resolve();
+      });
+
+      socket.on('error', (err) => {
+        reject(err);
+      });
+    });
+  }
+
+  createDuplex(options?: StreamOptions): Pipe {
+    if (!this.socket) {
+      throw new Error('Socket not initialized. Call listen() or connect() first.');
+    }
+    return new UnixPipeAdapterDuplex({
+      ...(options ?? {}),
+      socket: this.socket,
+    });
+  }
+
+  close(): void {
+    if (this.socket && !this.socket.destroyed) {
+      this.socket.destroy();
+    }
+    if (this.server) {
+      this.server.close();
+    }
+    this.isListening = false;
+    this.isConnected = false;
+  }
+}
