diff --git a/src/executor/Executor.ts b/src/executor/Executor.ts
index 187714b..88ac072 100644
--- a/src/executor/Executor.ts
+++ b/src/executor/Executor.ts
@@ -24,11 +24,31 @@ interface ModuleInstance {
   process?: ChildProcess;
 }
 
+interface HeartbeatConfig {
+  timeout: number;
+  maxMissed: number;
+  checkInterval: number;
+}
+
+interface CutoverConfig {
+  drainTimeout: number;
+  killTimeout: number;
+}
+
 export class Executor {
   private config?: TopologyConfig;
   private modules = new Map<string, ModuleInstance>();
   private moduleRegistry: ModuleRegistry;
   private logger?: TestLogger;
+  private heartbeatConfig: HeartbeatConfig = {
+    timeout: 10000,
+    maxMissed: 3,
+    checkInterval: 5000
+  };
+  private cutoverConfig: CutoverConfig = {
+    drainTimeout: 8000,
+    killTimeout: 5000
+  };
 
   constructor(
     private kernel: Kernel,
@@ -45,6 +65,14 @@ export class Executor {
     }
   }
 
+  setHeartbeatConfig(config: Partial<HeartbeatConfig>): void {
+    this.heartbeatConfig = { ...this.heartbeatConfig, ...config };
+  }
+
+  setCutoverConfig(config: Partial<CutoverConfig>): void {
+    this.cutoverConfig = { ...this.cutoverConfig, ...config };
+  }
+
   load(config: TopologyConfig): void {
     this.config = config;
   }
@@ -112,21 +140,43 @@ export class Executor {
     const proc = instance.process;
     if (!proc) return;
 
-    debug.emit('executor', 'process.drain', { nodeId: instance.id });
+    const drainStartTime = Date.now();
+    debug.emit('executor', 'process.drain', { 
+      nodeId: instance.id,
+      drainTimeout: this.cutoverConfig.drainTimeout,
+      killTimeout: this.cutoverConfig.killTimeout,
+      timestamp: drainStartTime
+    });
 
     const drainPromise = new Promise<void>((resolve) => {
       const timeout = setTimeout(() => {
-        debug.emit('executor', 'process.drain.timeout', { nodeId: instance.id });
+        const elapsed = Date.now() - drainStartTime;
+        debug.emit('executor', 'process.drain.timeout', { 
+          nodeId: instance.id,
+          elapsed,
+          configuredTimeout: this.cutoverConfig.drainTimeout,
+          timestamp: Date.now()
+        }, 'warn');
         resolve();
-      }, 5000);
+      }, this.cutoverConfig.drainTimeout);
 
       if (instance.module.outputPipe) {
         instance.module.outputPipe.once('end', () => {
+          const elapsed = Date.now() - drainStartTime;
           clearTimeout(timeout);
+          debug.emit('executor', 'process.drain.complete', {
+            nodeId: instance.id,
+            elapsed,
+            timestamp: Date.now()
+          });
           resolve();
         });
       } else {
         clearTimeout(timeout);
+        debug.emit('executor', 'process.drain.skipped', {
+          nodeId: instance.id,
+          reason: 'no-output-pipe'
+        });
         resolve();
       }
     });
@@ -141,13 +191,20 @@ export class Executor {
       const killTimer = setTimeout(() => {
         if (proc && !proc.killed) {
           proc.kill('SIGKILL');
-          debug.emit('executor', 'process.force-kill', { nodeId: instance.id });
+          debug.emit('executor', 'process.force-kill', { 
+            nodeId: instance.id,
+            killTimeout: this.cutoverConfig.killTimeout,
+            timestamp: Date.now()
+          }, 'warn');
         }
-      }, 5000);
+      }, this.cutoverConfig.killTimeout);
 
       proc.once('exit', () => {
         clearTimeout(killTimer);
-        debug.emit('executor', 'process.teardown.complete', { nodeId: instance.id });
+        debug.emit('executor', 'process.teardown.complete', { 
+          nodeId: instance.id,
+          timestamp: Date.now()
+        });
         resolve();
       });
 
@@ -247,20 +304,59 @@ export class Executor {
     });
 
     let lastHeartbeat = Date.now();
-    const heartbeatTimeout = nodeConfig.params?.heartbeatTimeout || 30000;
+    let missedCount = 0;
+    const heartbeatTimeout = nodeConfig.params?.heartbeatTimeout || this.heartbeatConfig.timeout;
+    const maxMissed = nodeConfig.params?.maxMissedHeartbeats || this.heartbeatConfig.maxMissed;
+    const checkInterval = nodeConfig.params?.heartbeatCheckInterval || this.heartbeatConfig.checkInterval;
 
     const heartbeatInterval = setInterval(() => {
       const elapsed = Date.now() - lastHeartbeat;
       if (elapsed > heartbeatTimeout) {
-        debug.emit('executor', 'process.heartbeat.timeout', { nodeId: nodeConfig.id, elapsed }, 'error');
-        proc.kill('SIGTERM');
-        clearInterval(heartbeatInterval);
+        missedCount++;
+        debug.emit('executor', 'process.heartbeat.missed', { 
+          nodeId: nodeConfig.id, 
+          elapsed,
+          missedCount,
+          maxMissed,
+          heartbeatTimeout,
+          timestamp: Date.now()
+        }, 'warn');
+
+        if (missedCount >= maxMissed) {
+          debug.emit('executor', 'process.heartbeat.timeout', { 
+            nodeId: nodeConfig.id, 
+            elapsed,
+            missedCount,
+            maxMissed,
+            heartbeatTimeout,
+            timestamp: Date.now()
+          }, 'error');
+          proc.kill('SIGTERM');
+          clearInterval(heartbeatInterval);
+        }
+      } else {
+        if (missedCount > 0) {
+          debug.emit('executor', 'process.heartbeat.recovered', {
+            nodeId: nodeConfig.id,
+            previousMissedCount: missedCount,
+            timestamp: Date.now()
+          });
+          missedCount = 0;
+        }
       }
-    }, heartbeatTimeout / 2);
+    }, checkInterval);
 
     proc.on('message', (msg: any) => {
       if (msg && msg.type === 'heartbeat') {
+        const wasLate = Date.now() - lastHeartbeat > heartbeatTimeout;
         lastHeartbeat = Date.now();
+        if (wasLate && missedCount > 0) {
+          debug.emit('executor', 'process.heartbeat.late', {
+            nodeId: nodeConfig.id,
+            missedCount,
+            timestamp: Date.now()
+          });
+        }
       }
     });
 
