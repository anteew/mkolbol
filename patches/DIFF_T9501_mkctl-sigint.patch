diff --git a/scripts/mkctl.ts b/scripts/mkctl.ts
index 305af67..436ae02 100644
--- a/scripts/mkctl.ts
+++ b/scripts/mkctl.ts
@@ -7,6 +7,41 @@ import { StateManager } from '../src/state/StateManager.js';
 import { Executor } from '../src/executor/Executor.js';
 import { loadConfig } from '../src/config/loader.js';
 
+const EXIT_CODES = {
+  SUCCESS: 0,
+  USAGE: 64,
+  CONFIG_PARSE: 65,
+  CONFIG_NOT_FOUND: 66,
+  RUNTIME: 70,
+  INTERRUPTED: 130,
+} as const;
+
+class MkctlError extends Error {
+  constructor(message: string, public readonly code: number, options?: ErrorOptions) {
+    super(message, options);
+    this.name = 'MkctlError';
+  }
+}
+
+function logError(message: string): void {
+  console.error(`[mkctl] ${message}`);
+}
+
+function handleException(err: unknown): number {
+  if (err instanceof MkctlError) {
+    logError(err.message);
+    return err.code;
+  }
+
+  if (err instanceof Error) {
+    logError(`Unexpected error: ${err.message}`);
+  } else {
+    logError(`Unexpected error: ${String(err)}`);
+  }
+
+  return EXIT_CODES.RUNTIME;
+}
+
 function printHelp() {
   console.log(`mkctl - Microkernel Control CLI
 
@@ -66,53 +101,190 @@ async function main() {
       break;
     }
     case 'run': {
-      const args = process.argv.slice(3);
-      const fileIndex = args.indexOf('--file');
-      const durationIndex = args.indexOf('--duration');
-      
-      if (fileIndex === -1 || fileIndex === args.length - 1) {
-        console.error('Usage: mkctl run --file <path> [--duration <seconds>]');
-        process.exit(1);
+      try {
+        const exitCode = await handleRunCommand(process.argv.slice(3));
+        process.exit(exitCode);
+      } catch (err: unknown) {
+        const code = handleException(err);
+        process.exit(code);
       }
-      
-      const configPath = args[fileIndex + 1];
-      const duration = durationIndex !== -1 && durationIndex < args.length - 1
-        ? parseInt(args[durationIndex + 1], 10) * 1000
-        : 5000;
-      
-      console.log(`Loading config from: ${configPath}`);
-      const config = loadConfig(configPath);
-      
-      const kernel = new Kernel();
-      const hostess = new Hostess();
-      const stateManager = new StateManager(kernel);
-      const executor = new Executor(kernel, hostess, stateManager);
-      
-      executor.load(config);
-      
-      console.log('Bringing topology up...');
-      await executor.up();
-      
-      console.log(`Topology running for ${duration / 1000} seconds...\n`);
-      
-      await new Promise(resolve => setTimeout(resolve, duration));
-      
-      console.log('\nBringing topology down...');
-      await executor.down();
-      
-      console.log('Done.');
-      process.exit(0);
+      return;
     }
     default:
       printHelp();
       if (cmd) {
-        console.error(`\nUnknown command: ${cmd}`);
-        process.exit(1);
+        logError(`Unknown command: ${cmd}`);
+        process.exit(EXIT_CODES.USAGE);
       }
+      return;
   }
 }
 
 main().catch(e => {
-  console.error(e);
-  process.exit(1);
+  const code = handleException(e);
+  process.exit(code);
 });
+
+interface RunArguments {
+  configPath: string;
+  durationMs: number;
+}
+
+function parseRunArgs(args: string[]): RunArguments {
+  let configPath: string | undefined;
+  let durationMs = 5000;
+
+  for (let i = 0; i < args.length; i++) {
+    const token = args[i];
+    if (token === '--file') {
+      const next = args[i + 1];
+      if (!next || next.startsWith('--')) {
+        throw new MkctlError('Usage: mkctl run --file <path> [--duration <seconds>]', EXIT_CODES.USAGE);
+      }
+      configPath = next;
+      i++;
+    } else if (token === '--duration') {
+      const next = args[i + 1];
+      if (!next || next.startsWith('--')) {
+        throw new MkctlError('Usage: mkctl run --file <path> [--duration <seconds>]', EXIT_CODES.USAGE);
+      }
+      const parsed = Number.parseInt(next, 10);
+      if (Number.isNaN(parsed) || parsed <= 0) {
+        throw new MkctlError('Duration must be a positive integer (seconds).', EXIT_CODES.USAGE);
+      }
+      durationMs = parsed * 1000;
+      i++;
+    }
+  }
+
+  if (!configPath) {
+    throw new MkctlError('Usage: mkctl run --file <path> [--duration <seconds>]', EXIT_CODES.USAGE);
+  }
+
+  return { configPath, durationMs };
+}
+
+async function waitForDurationOrSignal(durationMs: number): Promise<'timer' | 'signal'> {
+  return new Promise((resolve) => {
+    let settled = false;
+
+    const cleanup = () => {
+      process.off('SIGINT', onSignal);
+      process.off('SIGTERM', onSignal);
+    };
+
+    const onSignal = (signal: NodeJS.Signals) => {
+      if (settled) return;
+      settled = true;
+      console.log(`\nReceived ${signal}. Shutting down...`);
+      clearTimeout(timer);
+      cleanup();
+      resolve('signal');
+    };
+
+    const timer = setTimeout(() => {
+      if (settled) return;
+      settled = true;
+      cleanup();
+      resolve('timer');
+    }, durationMs);
+
+    process.once('SIGINT', onSignal);
+    process.once('SIGTERM', onSignal);
+  });
+}
+
+async function handleRunCommand(args: string[]): Promise<number> {
+  const { configPath, durationMs } = parseRunArgs(args);
+
+  try {
+    await fs.access(configPath);
+  } catch {
+    throw new MkctlError(
+      `Config file not found: ${configPath}\nHint: confirm the path or pick one from examples/configs.`,
+      EXIT_CODES.CONFIG_NOT_FOUND
+    );
+  }
+
+  console.log(`Loading config from: ${configPath}`);
+
+  let config;
+  try {
+    config = loadConfig(configPath);
+  } catch (err: unknown) {
+    const message = err instanceof Error ? err.message : String(err);
+    const validationIndicators = [
+      'Configuration must',
+      'Duplicate node id',
+      'address "',
+      'node "',
+      '"nodes" must be an array',
+      '"connections" must be an array'
+    ];
+    const isValidationIssue = validationIndicators.some(pattern => message.includes(pattern));
+    if (isValidationIssue) {
+      throw new MkctlError(
+        `Configuration validation failed: ${message}\nHint: ensure nodes[] and connections[] are defined with unique IDs.`,
+        EXIT_CODES.CONFIG_PARSE,
+        { cause: err }
+      );
+    }
+    throw new MkctlError(
+      `Failed to read config ${configPath}: ${message}\nHint: validate that the file contains well-formed YAML or JSON.`,
+      EXIT_CODES.CONFIG_PARSE,
+      { cause: err }
+    );
+  }
+
+  const kernel = new Kernel();
+  const hostess = new Hostess();
+  const stateManager = new StateManager(kernel);
+  const executor = new Executor(kernel, hostess, stateManager);
+
+  try {
+    executor.load(config);
+  } catch (err: unknown) {
+    const message = err instanceof Error ? err.message : String(err);
+    throw new MkctlError(
+      `Configuration validation failed: ${message}\nHint: ensure nodes[] and connections[] are defined with unique IDs.`,
+      EXIT_CODES.CONFIG_PARSE,
+      { cause: err }
+    );
+  }
+
+  console.log('Bringing topology up...');
+  try {
+    await executor.up();
+  } catch (err: unknown) {
+    const message = err instanceof Error ? err.message : String(err);
+    throw new MkctlError(
+      `Failed to start topology: ${message}\nHint: verify module names and external commands referenced by the config.`,
+      EXIT_CODES.RUNTIME,
+      { cause: err }
+    );
+  }
+
+  console.log(`Topology running for ${durationMs / 1000} seconds...\n`);
+
+  const outcome = await waitForDurationOrSignal(durationMs);
+
+  console.log('\nBringing topology down...');
+  try {
+    await executor.down();
+  } catch (err: unknown) {
+    const message = err instanceof Error ? err.message : String(err);
+    throw new MkctlError(
+      `Failed while shutting down topology: ${message}\nHint: inspect module shutdown hooks or external process logs.`,
+      EXIT_CODES.RUNTIME,
+      { cause: err }
+    );
+  }
+
+  if (outcome === 'signal') {
+    console.log('Interrupted.');
+    return EXIT_CODES.INTERRUPTED;
+  }
+
+  console.log('Done.');
+  return EXIT_CODES.SUCCESS;
+}
diff --git a/tests/cli/mkctlRun.spec.ts b/tests/cli/mkctlRun.spec.ts
index 83378d8..c511306 100644
--- a/tests/cli/mkctlRun.spec.ts
+++ b/tests/cli/mkctlRun.spec.ts
@@ -8,6 +8,15 @@ describe('mkctl run', () => {
   const testConfigDir = join(__dirname, '../fixtures/cli-configs');
   let tempFiles: string[] = [];
 
+  const EXIT_CODES = {
+    SUCCESS: 0,
+    USAGE: 64,
+    CONFIG_PARSE: 65,
+    CONFIG_NOT_FOUND: 66,
+    RUNTIME: 70,
+    INTERRUPTED: 130,
+  } as const;
+
   beforeEach(() => {
     if (!existsSync(testConfigDir)) {
       mkdirSync(testConfigDir, { recursive: true });
@@ -27,24 +36,24 @@ describe('mkctl run', () => {
     tempFiles = [];
   });
 
-  function runMkctl(args: string[], timeout: number = 5000): Promise<{ stdout: string; stderr: string; code: number | null }> {
-    return new Promise((resolve, reject) => {
-      const proc = spawn('tsx', [mkctlPath, ...args], {
-        cwd: join(__dirname, '../..'),
-        env: { ...process.env }
-      });
+  function spawnMkctl(args: string[], timeout: number = 5000): { proc: ChildProcess; result: Promise<{ stdout: string; stderr: string; code: number | null }> } {
+    const proc = spawn('tsx', [mkctlPath, ...args], {
+      cwd: join(__dirname, '../..'),
+      env: { ...process.env }
+    });
 
-      let stdout = '';
-      let stderr = '';
+    let stdout = '';
+    let stderr = '';
 
-      proc.stdout?.on('data', (data) => {
-        stdout += data.toString();
-      });
+    proc.stdout?.on('data', (data) => {
+      stdout += data.toString();
+    });
 
-      proc.stderr?.on('data', (data) => {
-        stderr += data.toString();
-      });
+    proc.stderr?.on('data', (data) => {
+      stderr += data.toString();
+    });
 
+    const result = new Promise<{ stdout: string; stderr: string; code: number | null }>((resolve, reject) => {
       const timer = setTimeout(() => {
         proc.kill('SIGTERM');
       }, timeout);
@@ -59,28 +68,35 @@ describe('mkctl run', () => {
         reject(err);
       });
     });
+
+    return { proc, result };
+  }
+
+  function runMkctl(args: string[], timeout: number = 5000) {
+    return spawnMkctl(args, timeout).result;
   }
 
   describe('--file argument parsing', () => {
     it('should error when --file is missing', async () => {
       const result = await runMkctl(['run'], 1000);
       
-      expect(result.code).toBe(1);
+      expect(result.code).toBe(EXIT_CODES.USAGE);
       expect(result.stderr).toContain('Usage: mkctl run --file <path>');
     });
 
     it('should error when --file has no value', async () => {
       const result = await runMkctl(['run', '--file'], 1000);
       
-      expect(result.code).toBe(1);
+      expect(result.code).toBe(EXIT_CODES.USAGE);
       expect(result.stderr).toContain('Usage: mkctl run --file <path>');
     });
 
     it('should error when config file does not exist', async () => {
       const result = await runMkctl(['run', '--file', '/nonexistent/config.yml'], 1000);
       
-      expect(result.code).toBe(1);
-      expect(result.stderr).toBeTruthy();
+      expect(result.code).toBe(EXIT_CODES.CONFIG_NOT_FOUND);
+      expect(result.stderr).toContain('Config file not found');
+      expect(result.stderr).toContain('Hint:');
     });
   });
 
@@ -104,7 +120,7 @@ connections: []
       const result = await runMkctl(['run', '--file', configPath], 8000);
       const elapsed = Date.now() - start;
 
-      expect(result.code).toBe(0);
+      expect(result.code).toBe(EXIT_CODES.SUCCESS);
       expect(result.stdout).toContain('Topology running for 5 seconds');
       expect(elapsed).toBeGreaterThanOrEqual(5000);
       expect(elapsed).toBeLessThan(6000);
@@ -119,7 +135,7 @@ connections: []
       const result = await runMkctl(['run', '--file', configPath, '--duration', '1'], 3000);
       const elapsed = Date.now() - start;
 
-      expect(result.code).toBe(0);
+      expect(result.code).toBe(EXIT_CODES.SUCCESS);
       expect(result.stdout).toContain('Topology running for 1 seconds');
       expect(elapsed).toBeGreaterThanOrEqual(1000);
       expect(elapsed).toBeLessThan(2000);
@@ -134,7 +150,7 @@ connections: []
       const result = await runMkctl(['run', '--duration', '1', '--file', configPath], 3000);
       const elapsed = Date.now() - start;
 
-      expect(result.code).toBe(0);
+      expect(result.code).toBe(EXIT_CODES.SUCCESS);
       expect(result.stdout).toContain('Topology running for 1 seconds');
       expect(elapsed).toBeGreaterThanOrEqual(1000);
       expect(elapsed).toBeLessThan(2000);
@@ -158,8 +174,9 @@ connections: []
 
       const result = await runMkctl(['run', '--file', configPath, '--duration', '1'], 2000);
 
-      expect(result.code).toBe(1);
-      expect(result.stderr).toBeTruthy();
+      expect(result.code).toBe(EXIT_CODES.CONFIG_PARSE);
+      expect(result.stderr).toContain('Failed to read config');
+      expect(result.stderr).toContain('Hint:');
     });
 
     it('should handle missing nodes array', async () => {
@@ -172,8 +189,10 @@ connections: []
 
       const result = await runMkctl(['run', '--file', configPath, '--duration', '1'], 2000);
 
-      expect(result.code).toBe(1);
+      expect(result.code).toBe(EXIT_CODES.CONFIG_PARSE);
       expect(result.stderr).toContain('Configuration must have a "nodes" array');
+      expect(result.stderr).toContain('Configuration validation failed');
+      expect(result.stderr).toContain('Hint:');
     });
 
     it('should handle missing connections array', async () => {
@@ -188,8 +207,9 @@ nodes:
 
       const result = await runMkctl(['run', '--file', configPath, '--duration', '1'], 2000);
 
-      expect(result.code).toBe(1);
+      expect(result.code).toBe(EXIT_CODES.CONFIG_PARSE);
       expect(result.stderr).toContain('Configuration must have a "connections" array');
+      expect(result.stderr).toContain('Hint:');
     });
 
     it('should handle duplicate node IDs', async () => {
@@ -207,8 +227,9 @@ connections: []
 
       const result = await runMkctl(['run', '--file', configPath, '--duration', '1'], 2000);
 
-      expect(result.code).toBe(1);
+      expect(result.code).toBe(EXIT_CODES.CONFIG_PARSE);
       expect(result.stderr).toContain('Duplicate node id: "timer1"');
+      expect(result.stderr).toContain('Hint:');
     });
 
     it('should handle invalid connection references', async () => {
@@ -226,8 +247,28 @@ connections:
 
       const result = await runMkctl(['run', '--file', configPath, '--duration', '1'], 2000);
 
-      expect(result.code).toBe(1);
+      expect(result.code).toBe(EXIT_CODES.CONFIG_PARSE);
       expect(result.stderr).toContain('node "nonexistent" referenced in "to" does not exist');
+      expect(result.stderr).toContain('Hint:');
+    });
+
+    it('should map runtime errors to runtime exit code', async () => {
+      const invalidRuntimeConfig = `
+nodes:
+  - id: crashy
+    module: DoesNotExist
+
+connections: []
+`;
+      const configPath = join(testConfigDir, 'runtime-error.yml');
+      writeFileSync(configPath, invalidRuntimeConfig);
+      tempFiles.push(configPath);
+
+      const result = await runMkctl(['run', '--file', configPath, '--duration', '1'], 2000);
+
+      expect(result.code).toBe(EXIT_CODES.RUNTIME);
+      expect(result.stderr).toContain('Failed to start topology');
+      expect(result.stderr).toContain('Hint:');
     });
   });
 
@@ -238,7 +279,7 @@ connections:
       const configPath = join(examplesDir, 'basic.yml');
       const result = await runMkctl(['run', '--file', configPath, '--duration', '1'], 3000);
 
-      expect(result.code).toBe(0);
+      expect(result.code).toBe(EXIT_CODES.SUCCESS);
       expect(result.stdout).toContain('Loading config from:');
       expect(result.stdout).toContain('Bringing topology up');
       expect(result.stdout).toContain('Topology running for 1 seconds');
@@ -250,7 +291,7 @@ connections:
       const configPath = join(examplesDir, 'multi.yml');
       const result = await runMkctl(['run', '--file', configPath, '--duration', '1'], 3000);
 
-      expect(result.code).toBe(0);
+      expect(result.code).toBe(EXIT_CODES.SUCCESS);
       expect(result.stdout).toContain('Loading config from:');
       expect(result.stdout).toContain('Bringing topology up');
       expect(result.stdout).toContain('Topology running for 1 seconds');
@@ -262,7 +303,7 @@ connections:
       const configPath = join(examplesDir, 'external-pty.yaml');
       const result = await runMkctl(['run', '--file', configPath, '--duration', '1'], 3000);
 
-      expect(result.code).toBe(0);
+      expect(result.code).toBe(EXIT_CODES.SUCCESS);
       expect(result.stdout).toContain('Loading config from:');
       expect(result.stdout).toContain('Bringing topology up');
       expect(result.stdout).toContain('Done');
@@ -272,7 +313,7 @@ connections:
       const configPath = join(examplesDir, 'external-stdio.yaml');
       const result = await runMkctl(['run', '--file', configPath, '--duration', '1'], 3000);
 
-      expect(result.code).toBe(0);
+      expect(result.code).toBe(EXIT_CODES.SUCCESS);
       expect(result.stdout).toContain('Loading config from:');
       expect(result.stdout).toContain('Bringing topology up');
       expect(result.stdout).toContain('Done');
@@ -309,7 +350,7 @@ connections:
 
       const result = await runMkctl(['run', '--file', configPath, '--duration', '1'], 3000);
 
-      expect(result.code).toBe(0);
+      expect(result.code).toBe(EXIT_CODES.SUCCESS);
       expect(result.stdout).toContain('Bringing topology up');
       expect(result.stdout).toContain('Done');
     });
@@ -330,7 +371,7 @@ connections: []
 
       const result = await runMkctl(['run', '--file', configPath, '--duration', '1'], 3000);
 
-      expect(result.code).toBe(0);
+      expect(result.code).toBe(EXIT_CODES.SUCCESS);
       expect(result.stdout).toContain('Done');
     });
 
@@ -351,8 +392,38 @@ connections: []
 
       const result = await runMkctl(['run', '--file', configPath, '--duration', '1'], 3000);
 
-      expect(result.code).toBe(0);
+      expect(result.code).toBe(EXIT_CODES.SUCCESS);
       expect(result.stdout).toContain('Done');
     });
   });
+
+  describe('signal handling', () => {
+    const validConfig = `
+nodes:
+  - id: timer1
+    module: TimerSource
+    params:
+      periodMs: 200
+
+connections: []
+`;
+
+    it('should shut down gracefully on SIGINT', async () => {
+      const configPath = join(testConfigDir, 'sigint-config.yml');
+      writeFileSync(configPath, validConfig);
+      tempFiles.push(configPath);
+
+      const { proc, result } = spawnMkctl(['run', '--file', configPath, '--duration', '10'], 10000);
+
+      // Wait briefly for the topology to come up
+      await new Promise(resolve => setTimeout(resolve, 500));
+      proc.kill('SIGINT');
+
+      const outcome = await result;
+
+      expect(outcome.code).toBe(EXIT_CODES.INTERRUPTED);
+      expect(outcome.stdout).toContain('Received SIGINT');
+      expect(outcome.stdout).toContain('Bringing topology down');
+    });
+  });
 });
