diff --git a/src/test/reporter/jsonlReporter.ts b/src/test/reporter/jsonlReporter.ts
index cc304e2..5cbcd5a 100644
--- a/src/test/reporter/jsonlReporter.ts
+++ b/src/test/reporter/jsonlReporter.ts
@@ -10,11 +10,33 @@ interface TestSummary {
   error?: string;
 }
 
+interface ArtifactIndexEntry {
+  testName: string;
+  status: 'pass' | 'fail' | 'skip';
+  duration: number;
+  location: string;
+  timestamp: string;
+  artifacts: {
+    summary: string;
+    caseFile?: string;
+    digestFile?: string;
+  };
+}
+
+interface ArtifactIndex {
+  generated: string;
+  totalTests: number;
+  artifacts: ArtifactIndexEntry[];
+}
+
 export default class JSONLReporter implements Reporter {
   private ctx!: Vitest;
   private summaryPath = 'reports/summary.jsonl';
+  private indexPath = 'reports/index.json';
   private summaryStream?: fs.WriteStream;
   private processedTests = new Set<string>();
+  private indexEntries: ArtifactIndexEntry[] = [];
+  private caseStreams = new Map<string, fs.WriteStream>();
 
   onInit(ctx: Vitest): void {
     this.ctx = ctx;
@@ -24,6 +46,7 @@ export default class JSONLReporter implements Reporter {
       fs.unlinkSync(this.summaryPath);
     }
     this.summaryStream = fs.createWriteStream(this.summaryPath, { flags: 'a' });
+    this.indexEntries = [];
   }
 
   onCollected(): void {
@@ -38,6 +61,12 @@ export default class JSONLReporter implements Reporter {
     if (this.summaryStream) {
       this.summaryStream.end();
     }
+    // Close all per-case streams
+    for (const stream of this.caseStreams.values()) {
+      stream.end();
+    }
+    this.caseStreams.clear();
+    this.generateIndex();
   }
 
   private processFiles(files: File[]): void {
@@ -84,6 +113,9 @@ export default class JSONLReporter implements Reporter {
     const caseName = task.name.replace(/[^a-zA-Z0-9-_]/g, '_');
     const artifactURI = `reports/${suiteName}/${caseName}.jsonl`;
 
+    // Write per-case JSONL file with test lifecycle events
+    this.writePerCaseJSONL(artifactURI, task.name, state, duration, result.errors);
+
     const summary: TestSummary = {
       status: state,
       duration,
@@ -98,5 +130,101 @@ export default class JSONLReporter implements Reporter {
     if (this.summaryStream) {
       this.summaryStream.write(JSON.stringify(summary) + '\n');
     }
+
+    const suitePath = file ? path.basename(file.filepath, path.extname(file.filepath)) : 'unknown';
+    const digestPath = `reports/${suitePath}/digest.jsonl`;
+    
+    this.indexEntries.push({
+      testName: task.name,
+      status: state,
+      duration,
+      location,
+      timestamp: new Date().toISOString(),
+      artifacts: {
+        summary: this.summaryPath,
+        caseFile: artifactURI,
+        digestFile: fs.existsSync(digestPath) ? digestPath : undefined,
+      },
+    });
+  }
+
+  private writePerCaseJSONL(
+    artifactPath: string,
+    caseName: string,
+    state: 'pass' | 'fail' | 'skip',
+    duration: number,
+    errors?: any[]
+  ): void {
+    const dir = path.dirname(artifactPath);
+    fs.mkdirSync(dir, { recursive: true });
+
+    // Remove existing file if it exists
+    if (fs.existsSync(artifactPath)) {
+      fs.unlinkSync(artifactPath);
+    }
+
+    const stream = fs.createWriteStream(artifactPath, { flags: 'a' });
+    const ts = Date.now();
+
+    // Write test lifecycle events
+    // 1. Test begin event
+    stream.write(JSON.stringify({
+      ts,
+      lvl: 'info',
+      case: caseName,
+      phase: 'setup',
+      evt: 'case.begin'
+    }) + '\n');
+
+    // 2. Test execution event
+    stream.write(JSON.stringify({
+      ts: ts + 1,
+      lvl: 'info',
+      case: caseName,
+      phase: 'execution',
+      evt: 'test.run'
+    }) + '\n');
+
+    // 3. If there are errors, write error events
+    if (errors && errors.length > 0) {
+      errors.forEach((error, idx) => {
+        stream.write(JSON.stringify({
+          ts: ts + 2 + idx,
+          lvl: 'error',
+          case: caseName,
+          phase: 'execution',
+          evt: 'test.error',
+          payload: {
+            message: error.message || String(error),
+            stack: error.stack
+          }
+        }) + '\n');
+      });
+    }
+
+    // 4. Test end event with result
+    stream.write(JSON.stringify({
+      ts: ts + 2 + (errors?.length || 0),
+      lvl: state === 'fail' ? 'error' : 'info',
+      case: caseName,
+      phase: 'teardown',
+      evt: 'case.end',
+      payload: {
+        duration,
+        status: state === 'pass' ? 'passed' : state === 'fail' ? 'failed' : 'skipped'
+      }
+    }) + '\n');
+
+    stream.end();
+  }
+
+  private generateIndex(): void {
+    const index: ArtifactIndex = {
+      generated: new Date().toISOString(),
+      totalTests: this.indexEntries.length,
+      artifacts: this.indexEntries,
+    };
+
+    fs.writeFileSync(this.indexPath, JSON.stringify(index, null, 2));
   }
 }
