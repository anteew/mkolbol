diff --git a/package.json b/package.json
index f0ee9c4..90676a9 100644
--- a/package.json
+++ b/package.json
@@ -34,6 +34,7 @@
     "logq": "tsx scripts/logq.ts",
     "repro": "tsx scripts/repro.ts",
     "laminar:run": "tsx scripts/laminar-run.ts",
+    "laminar:digest": "tsx scripts/digest.ts",
     "dev": "node --enable-source-maps dist/examples/basic-topology.js",
     "dev:split": "node --enable-source-maps dist/examples/split-topology.js",
     "dev:merge": "node --enable-source-maps dist/examples/merge-topology.js",
diff --git a/scripts/digest.ts b/scripts/digest.ts
new file mode 100644
index 0000000..8003107
--- /dev/null
+++ b/scripts/digest.ts
@@ -0,0 +1,22 @@
+#!/usr/bin/env tsx
+import { generateAllDigests } from '../src/digest/generator.js';
+
+async function main() {
+  console.log('Laminar Digest Generator');
+  console.log('========================\n');
+
+  const configPath = process.argv[2] || 'laminar.config.json';
+  
+  const count = await generateAllDigests(configPath);
+  
+  if (count === 0) {
+    console.log('\nNo failing test cases found.');
+  } else {
+    console.log(`\nGenerated ${count} digest(s).`);
+  }
+}
+
+main().catch((err) => {
+  console.error('Error:', err);
+  process.exit(1);
+});
diff --git a/src/digest/generator.ts b/src/digest/generator.ts
new file mode 100644
index 0000000..5aeb168
--- /dev/null
+++ b/src/digest/generator.ts
@@ -0,0 +1,318 @@
+import * as fs from 'node:fs';
+import * as path from 'node:path';
+
+export interface DigestConfig {
+  budget?: {
+    kb?: number;
+    lines?: number;
+  };
+  rules?: DigestRule[];
+  enabled?: boolean;
+}
+
+export interface DigestRule {
+  match: {
+    evt?: string | string[];
+    lvl?: string | string[];
+    phase?: string | string[];
+  };
+  actions: DigestAction[];
+  priority?: number;
+}
+
+export interface DigestAction {
+  type: 'include' | 'slice' | 'redact';
+  window?: number;
+  field?: string;
+}
+
+export interface DigestEvent {
+  ts: number;
+  lvl: string;
+  case: string;
+  phase?: string;
+  evt: string;
+  id?: string;
+  corr?: string;
+  path?: string;
+  payload?: unknown;
+}
+
+export interface DigestOutput {
+  case: string;
+  status: 'fail';
+  duration: number;
+  location: string;
+  error?: string;
+  summary: {
+    totalEvents: number;
+    includedEvents: number;
+    redactedFields: number;
+    budgetUsed: number;
+    budgetLimit: number;
+  };
+  events: DigestEvent[];
+}
+
+const DEFAULT_CONFIG: DigestConfig = {
+  budget: {
+    kb: 10,
+    lines: 200,
+  },
+  enabled: true,
+  rules: [
+    {
+      match: { lvl: 'error' },
+      actions: [{ type: 'include' }],
+      priority: 100,
+    },
+    {
+      match: { evt: 'assert.fail' },
+      actions: [{ type: 'include' }, { type: 'slice', window: 10 }],
+      priority: 90,
+    },
+  ],
+};
+
+export class DigestGenerator {
+  private config: DigestConfig;
+
+  constructor(config?: DigestConfig) {
+    this.config = config || DEFAULT_CONFIG;
+  }
+
+  static loadConfig(configPath: string = 'laminar.config.json'): DigestConfig {
+    if (fs.existsSync(configPath)) {
+      try {
+        const content = fs.readFileSync(configPath, 'utf-8');
+        return JSON.parse(content);
+      } catch (e) {
+        console.warn(`Failed to load ${configPath}, using defaults:`, e);
+      }
+    }
+    return DEFAULT_CONFIG;
+  }
+
+  async generateDigest(
+    caseName: string,
+    status: 'pass' | 'fail' | 'skip',
+    duration: number,
+    location: string,
+    artifactURI: string,
+    error?: string
+  ): Promise<DigestOutput | null> {
+    if (status !== 'fail') {
+      return null;
+    }
+
+    if (!this.config.enabled) {
+      return null;
+    }
+
+    const events = this.loadEvents(artifactURI);
+    const processedEvents = this.applyRules(events);
+    const budgetedEvents = this.enforceBudget(processedEvents);
+
+    const budgetLimit = (this.config.budget?.kb || 10) * 1024;
+    const budgetUsed = JSON.stringify(budgetedEvents).length;
+
+    return {
+      case: caseName,
+      status: 'fail',
+      duration,
+      location,
+      error,
+      summary: {
+        totalEvents: events.length,
+        includedEvents: budgetedEvents.length,
+        redactedFields: 0,
+        budgetUsed,
+        budgetLimit,
+      },
+      events: budgetedEvents,
+    };
+  }
+
+  private loadEvents(artifactURI: string): DigestEvent[] {
+    if (!fs.existsSync(artifactURI)) {
+      return [];
+    }
+
+    const content = fs.readFileSync(artifactURI, 'utf-8');
+    const lines = content.trim().split('\n').filter(Boolean);
+    const events: DigestEvent[] = [];
+
+    for (const line of lines) {
+      try {
+        events.push(JSON.parse(line));
+      } catch (e) {
+        console.warn('Failed to parse event:', line);
+      }
+    }
+
+    return events;
+  }
+
+  private applyRules(events: DigestEvent[]): DigestEvent[] {
+    if (!this.config.rules || this.config.rules.length === 0) {
+      return events;
+    }
+
+    const included = new Set<number>();
+    const rules = [...this.config.rules].sort((a, b) => (b.priority || 0) - (a.priority || 0));
+
+    for (const rule of rules) {
+      for (let i = 0; i < events.length; i++) {
+        if (this.matchEvent(events[i], rule.match)) {
+          for (const action of rule.actions) {
+            if (action.type === 'include') {
+              included.add(i);
+            } else if (action.type === 'slice' && action.window) {
+              const window = action.window;
+              for (let j = Math.max(0, i - window); j < Math.min(events.length, i + window + 1); j++) {
+                included.add(j);
+              }
+            }
+          }
+        }
+      }
+    }
+
+    if (included.size === 0) {
+      return events;
+    }
+
+    return Array.from(included)
+      .sort((a, b) => a - b)
+      .map(idx => events[idx]);
+  }
+
+  private matchEvent(event: DigestEvent, match: DigestRule['match']): boolean {
+    if (match.evt) {
+      const evtMatch = Array.isArray(match.evt) ? match.evt : [match.evt];
+      if (!evtMatch.includes(event.evt)) return false;
+    }
+
+    if (match.lvl) {
+      const lvlMatch = Array.isArray(match.lvl) ? match.lvl : [match.lvl];
+      if (!lvlMatch.includes(event.lvl)) return false;
+    }
+
+    if (match.phase) {
+      const phaseMatch = Array.isArray(match.phase) ? match.phase : [match.phase];
+      if (!event.phase || !phaseMatch.includes(event.phase)) return false;
+    }
+
+    return true;
+  }
+
+  private enforceBudget(events: DigestEvent[]): DigestEvent[] {
+    const budgetKb = this.config.budget?.kb || 10;
+    const budgetLines = this.config.budget?.lines || 200;
+    const budgetBytes = budgetKb * 1024;
+
+    if (events.length <= budgetLines) {
+      const size = JSON.stringify(events).length;
+      if (size <= budgetBytes) {
+        return events;
+      }
+    }
+
+    let currentEvents = events.slice(0, Math.min(events.length, budgetLines));
+    while (currentEvents.length > 0) {
+      const size = JSON.stringify(currentEvents).length;
+      if (size <= budgetBytes) {
+        break;
+      }
+      currentEvents = currentEvents.slice(0, currentEvents.length - 1);
+    }
+
+    return currentEvents;
+  }
+
+  async writeDigest(digest: DigestOutput, outputDir: string = 'reports'): Promise<void> {
+    const digestJsonPath = path.join(outputDir, `${digest.case}.digest.json`);
+    const digestMdPath = path.join(outputDir, `${digest.case}.digest.md`);
+
+    fs.mkdirSync(outputDir, { recursive: true });
+
+    fs.writeFileSync(digestJsonPath, JSON.stringify(digest, null, 2));
+
+    const md = this.formatMarkdown(digest);
+    fs.writeFileSync(digestMdPath, md);
+  }
+
+  private formatMarkdown(digest: DigestOutput): string {
+    const lines: string[] = [];
+
+    lines.push(`# Digest: ${digest.case}`);
+    lines.push('');
+    lines.push(`**Status**: ${digest.status}`);
+    lines.push(`**Duration**: ${digest.duration}ms`);
+    lines.push(`**Location**: ${digest.location}`);
+    if (digest.error) {
+      lines.push(`**Error**: ${digest.error}`);
+    }
+    lines.push('');
+
+    lines.push('## Summary');
+    lines.push(`- Total Events: ${digest.summary.totalEvents}`);
+    lines.push(`- Included Events: ${digest.summary.includedEvents}`);
+    lines.push(`- Budget Used: ${digest.summary.budgetUsed} / ${digest.summary.budgetLimit} bytes`);
+    lines.push('');
+
+    if (digest.events.length > 0) {
+      lines.push('## Events');
+      lines.push('```json');
+      for (const evt of digest.events) {
+        lines.push(JSON.stringify(evt));
+      }
+      lines.push('```');
+    }
+
+    return lines.join('\n');
+  }
+}
+
+export async function generateAllDigests(configPath?: string): Promise<number> {
+  const summaryPath = 'reports/summary.jsonl';
+  if (!fs.existsSync(summaryPath)) {
+    console.log('No summary.jsonl found');
+    return 0;
+  }
+
+  const config = DigestGenerator.loadConfig(configPath);
+  const generator = new DigestGenerator(config);
+
+  const content = fs.readFileSync(summaryPath, 'utf-8');
+  const lines = content.trim().split('\n').filter(Boolean);
+
+  let count = 0;
+  for (const line of lines) {
+    try {
+      const entry = JSON.parse(line);
+      if (entry.status === 'fail' && entry.artifactURI) {
+        const caseName = path.basename(entry.artifactURI, '.jsonl');
+        const digest = await generator.generateDigest(
+          caseName,
+          entry.status,
+          entry.duration,
+          entry.location,
+          entry.artifactURI,
+          entry.error
+        );
+
+        if (digest) {
+          const outputDir = path.dirname(entry.artifactURI);
+          await generator.writeDigest(digest, outputDir);
+          console.log(`âœ“ Generated digest for ${caseName}`);
+          count++;
+        }
+      }
+    } catch (e) {
+      console.warn('Failed to process entry:', line, e);
+    }
+  }
+
+  return count;
+}
