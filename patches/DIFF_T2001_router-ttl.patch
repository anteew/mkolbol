diff --git a/src/router/RoutingServer.ts b/src/router/RoutingServer.ts
new file mode 100644
index 0000000..eede7ea
--- /dev/null
+++ b/src/router/RoutingServer.ts
@@ -0,0 +1,106 @@
+import { debug } from '../debug/api.js';
+import type { RoutingAnnouncement, RoutingEndpoint } from '../types.js';
+
+export interface RoutingServerConfig {
+  ttlMs?: number;
+  sweepIntervalMs?: number;
+}
+
+export class RoutingServer {
+  private endpoints = new Map<string, RoutingEndpoint>();
+  private ttlMs: number;
+  private sweepIntervalMs: number;
+  private sweepTimer?: NodeJS.Timeout;
+
+  constructor(config?: RoutingServerConfig) {
+    this.ttlMs = config?.ttlMs ?? 30000;
+    this.sweepIntervalMs = config?.sweepIntervalMs ?? 10000;
+  }
+
+  announce(announcement: RoutingAnnouncement): void {
+    const { id, type, coordinates, metadata } = announcement;
+    if (!id) {
+      throw new Error('RoutingServer.announce requires an "id"');
+    }
+
+    const now = Date.now();
+    const existing = this.endpoints.get(id);
+    const endpoint: RoutingEndpoint = existing
+      ? {
+          ...existing,
+          type,
+          coordinates,
+          metadata: metadata ? { ...metadata } : undefined,
+          updatedAt: now,
+        }
+      : {
+          id,
+          type,
+          coordinates,
+          metadata: metadata ? { ...metadata } : undefined,
+          announcedAt: now,
+          updatedAt: now,
+        };
+
+    this.endpoints.set(id, endpoint);
+    debug.emit('router', 'announce', { id, type, coordinates, metadata });
+  }
+
+  withdraw(id: string): void {
+    if (!id) return;
+    if (this.endpoints.delete(id)) {
+      debug.emit('router', 'withdraw', { id });
+    }
+  }
+
+  list(): RoutingEndpoint[] {
+    return Array.from(this.endpoints.values()).map((endpoint) => ({
+      ...endpoint,
+      metadata: endpoint.metadata ? { ...endpoint.metadata } : undefined,
+    }));
+  }
+
+  startSweeper(): void {
+    if (this.sweepTimer) return;
+    this.sweepTimer = setInterval(() => {
+      this.sweep();
+    }, this.sweepIntervalMs);
+  }
+
+  stopSweeper(): void {
+    if (this.sweepTimer) {
+      clearInterval(this.sweepTimer);
+      this.sweepTimer = undefined;
+    }
+  }
+
+  sweep(): void {
+    const now = Date.now();
+    const stale: string[] = [];
+
+    for (const [id, endpoint] of this.endpoints.entries()) {
+      const age = now - endpoint.updatedAt;
+      if (age > this.ttlMs) {
+        stale.push(id);
+        debug.emit('router', 'sweep.stale', {
+          id,
+          age,
+          ttlMs: this.ttlMs,
+          lastUpdated: endpoint.updatedAt
+        }, 'warn');
+      }
+    }
+
+    for (const id of stale) {
+      this.endpoints.delete(id);
+      debug.emit('router', 'sweep.removed', { id });
+    }
+
+    if (stale.length > 0) {
+      debug.emit('router', 'sweep.complete', {
+        removed: stale.length,
+        remaining: this.endpoints.size
+      });
+    }
+  }
+}
diff --git a/tests/integration/router-inproc.spec.ts b/tests/integration/router-inproc.spec.ts
new file mode 100644
index 0000000..d617ea1
--- /dev/null
+++ b/tests/integration/router-inproc.spec.ts
@@ -0,0 +1,140 @@
+import { describe, it, expect, afterEach } from 'vitest';
+import { RoutingServer } from '../../src/router/RoutingServer.js';
+import type { RoutingAnnouncement } from '../../src/types.js';
+
+describe('RoutingServer (in-process)', () => {
+  const baseAnnouncement: RoutingAnnouncement = {
+    id: 'console.out',
+    type: 'output',
+    coordinates: 'node:console1',
+    metadata: { module: 'ConsoleSink', runMode: 'inproc' },
+  };
+
+  let router: RoutingServer | undefined;
+
+  afterEach(() => {
+    router?.stopSweeper();
+    router = undefined;
+  });
+
+  it('stores announcements and returns copies via list()', () => {
+    router = new RoutingServer();
+
+    router.announce(baseAnnouncement);
+
+    const endpoints = router.list();
+    expect(endpoints).toHaveLength(1);
+
+    const endpoint = endpoints[0];
+    expect(endpoint.id).toBe(baseAnnouncement.id);
+    expect(endpoint.type).toBe(baseAnnouncement.type);
+    expect(endpoint.coordinates).toBe(baseAnnouncement.coordinates);
+    expect(endpoint.metadata).toEqual(baseAnnouncement.metadata);
+    expect(endpoint.announcedAt).toBeGreaterThan(0);
+    expect(endpoint.updatedAt).toBeGreaterThanOrEqual(endpoint.announcedAt);
+
+    endpoint.metadata!.module = 'Mutated';
+    expect(router.list()[0].metadata?.module).toBe('ConsoleSink');
+  });
+
+  it('is idempotent and updates timestamps and metadata', async () => {
+    router = new RoutingServer();
+
+    router.announce(baseAnnouncement);
+    const first = router.list()[0];
+
+    const updatedAnnouncement: RoutingAnnouncement = {
+      ...baseAnnouncement,
+      metadata: { module: 'ConsoleSink', runMode: 'inproc', version: '1.1.0' },
+    };
+
+    await new Promise((resolve) => setTimeout(resolve, 5));
+    router.announce(updatedAnnouncement);
+
+    const second = router.list()[0];
+    expect(second.announcedAt).toBe(first.announcedAt);
+    expect(second.updatedAt).toBeGreaterThanOrEqual(first.updatedAt);
+    expect(second.metadata).toEqual(updatedAnnouncement.metadata);
+  });
+
+  it('withdraw removes endpoints', () => {
+    router = new RoutingServer();
+
+    router.announce(baseAnnouncement);
+    router.withdraw(baseAnnouncement.id);
+
+    expect(router.list()).toHaveLength(0);
+    expect(() => router.withdraw(baseAnnouncement.id)).not.toThrow();
+  });
+
+  it('sweep removes stale endpoints based on TTL', async () => {
+    router = new RoutingServer({ ttlMs: 100, sweepIntervalMs: 50 });
+
+    router.announce(baseAnnouncement);
+    expect(router.list()).toHaveLength(1);
+
+    await new Promise((resolve) => setTimeout(resolve, 150));
+    router.sweep();
+
+    expect(router.list()).toHaveLength(0);
+  });
+
+  it('sweep keeps fresh endpoints', async () => {
+    router = new RoutingServer({ ttlMs: 200, sweepIntervalMs: 50 });
+
+    router.announce(baseAnnouncement);
+    await new Promise((resolve) => setTimeout(resolve, 50));
+    router.announce(baseAnnouncement);
+    await new Promise((resolve) => setTimeout(resolve, 50));
+    router.sweep();
+
+    expect(router.list()).toHaveLength(1);
+  });
+
+  it('startSweeper automatically removes stale endpoints', async () => {
+    router = new RoutingServer({ ttlMs: 100, sweepIntervalMs: 60 });
+
+    router.announce(baseAnnouncement);
+    router.startSweeper();
+
+    expect(router.list()).toHaveLength(1);
+
+    await new Promise((resolve) => setTimeout(resolve, 200));
+
+    expect(router.list()).toHaveLength(0);
+  });
+
+  it('stopSweeper halts automatic cleanup', async () => {
+    router = new RoutingServer({ ttlMs: 100, sweepIntervalMs: 50 });
+
+    router.announce(baseAnnouncement);
+    router.startSweeper();
+    router.stopSweeper();
+
+    await new Promise((resolve) => setTimeout(resolve, 200));
+
+    expect(router.list()).toHaveLength(1);
+  });
+
+  it('allows multiple startSweeper calls without error', () => {
+    router = new RoutingServer();
+    router.startSweeper();
+    router.startSweeper();
+    router.startSweeper();
+    expect(() => router.stopSweeper()).not.toThrow();
+  });
+
+  it('heartbeat keeps endpoint alive', async () => {
+    router = new RoutingServer({ ttlMs: 150, sweepIntervalMs: 200 });
+
+    router.announce(baseAnnouncement);
+    router.startSweeper();
+
+    for (let i = 0; i < 3; i++) {
+      await new Promise((resolve) => setTimeout(resolve, 80));
+      router.announce(baseAnnouncement);
+    }
+
+    expect(router.list()).toHaveLength(1);
+  });
+});
