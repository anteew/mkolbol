name: Laminar Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

jobs:
  test:
    name: Test (Node ${{ matrix.node-version }})
    runs-on: ubuntu-latest
    
    strategy:
      fail-fast: false
      matrix:
        node-version: [20, 24]
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build
        run: npm run build
      
      - name: Run tests with Laminar
        run: npm run laminar:run || true
        env:
          CI: true
      
      - name: Run flake detection
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: npm run laminar:run -- --flake-detect
        continue-on-error: true
      
      - name: Generate digests
        if: always()
        run: npm run laminar:digest || true
      
      - name: Upload test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-reports-node-${{ matrix.node-version }}
          path: reports/
          retention-days: 30
      
      - name: Create issues for test failures
        if: github.event_name == 'push' && github.ref == 'refs/heads/main' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const summaryPath = 'reports/summary.jsonl';

            if (!fs.existsSync(summaryPath)) {
              console.log('No summary file found');
              return;
            }

            const lines = fs.readFileSync(summaryPath, 'utf-8').trim().split('\n');
            const entries = lines.map(l => {
              try { return JSON.parse(l); } catch { return null; }
            }).filter(Boolean);

            const failures = entries.filter(e => e.status === 'fail');

            if (failures.length === 0) {
              console.log('No failures to report');
              return;
            }

            // Create an issue for each unique failure
            for (const failure of failures.slice(0, 3)) {
              const testName = failure.testName || failure.location || 'Unknown test';
              const title = `Test failure: ${testName}`;

              // Check if issue already exists
              const existingIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: 'test-failure',
                per_page: 100
              });

              const issueExists = existingIssues.data.some(issue =>
                issue.title === title
              );

              if (issueExists) {
                console.log(`Issue already exists for: ${testName}`);
                continue;
              }

              // Read digest if available
              let digestContent = '';
              const digestPath = failure.artifactURI?.replace('.jsonl', '.digest.md');
              if (digestPath && fs.existsSync(digestPath)) {
                digestContent = fs.readFileSync(digestPath, 'utf-8');
              }

              const bodyParts = [
                '## Test Failure Report',
                '',
                '**Test**: `' + testName + '`',
                '**Duration**: ' + failure.duration + 'ms',
                '**Location**: ' + (failure.location || 'N/A'),
                '**Node Version**: ${{ matrix.node-version }}',
                '',
                '### Error',
                failure.error || 'No error message available',
                ''
              ];

              if (digestContent) {
                bodyParts.push('### Digest', '', '```', digestContent, '```', '');
              }

              bodyParts.push(
                '### Reproduction',
                '',
                '```bash',
                'npm run laminar:run',
                '```',
                '',
                '### Artifacts',
                '- [Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})',
                '- [Test Reports Artifact](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})',
                '',
                '---',
                '*This issue was automatically created by GitHub Actions*'
              );

              const body = bodyParts.join('\n');

              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['test-failure', 'automated']
              });

              console.log(`Created issue for: ${testName}`);
            }

      - name: Comment PR with test summary
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const summaryPath = 'reports/summary.jsonl';

            if (!fs.existsSync(summaryPath)) {
              console.log('No summary file found');
              return;
            }

            const lines = fs.readFileSync(summaryPath, 'utf-8').trim().split('\n');
            const entries = lines.map(l => {
              try { return JSON.parse(l); } catch { return null; }
            }).filter(Boolean);

            const passed = entries.filter(e => e.status === 'pass').length;
            const failed = entries.filter(e => e.status === 'fail').length;
            const skipped = entries.filter(e => e.status === 'skip').length;
            const total = entries.length;

            const failures = entries
              .filter(e => e.status === 'fail')
              .slice(0, 5)
              .map(e => `- \`${e.testName || e.location}\`${e.error ? ': ' + e.error.split('\n')[0] : ''}`)
              .join('\n');

            const body = `## Test Results (Node ${{ matrix.node-version }})

            ðŸ“Š **Summary**: ${passed} passed, ${failed} failed, ${skipped} skipped (${total} total)

            ${failed > 0 ? '### âŒ Failures\n\n' + failures + (failed > 5 ? `\n\n...and ${failed - 5} more` : '') : 'âœ… All tests passed!'}

            ðŸ“¦ [Download full reports](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;

            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.data.find(comment =>
              comment.user?.type === 'Bot' &&
              comment.body?.includes(`Test Results (Node ${{ matrix.node-version }})`)
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
